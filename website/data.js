// Auto-generated file - Run 'node generate-data.js' to update
const codeData = {
  "Arrays - Easy": [
    {
      "name": "Appears Once",
      "filename": "AppearsOnce.c++",
      "path": "practices/Arrays/Easy/AppearsOnce.c++",
      "content": "#include <iostream>\n#include <map>\nusing namespace std;\n\nint BruteReturn(int arr[], int n)\n{\n  for (int i = 0; i < n; i++)\n  {\n    int cnt = 0;\n    for (int j = 0; j < n; j++)\n    {\n      if (arr[i] == arr[j])\n      {\n        cnt++;\n      }\n    }\n    if (cnt == 1)\n    {\n      return arr[i];\n    }\n  }\n\n  return -1;\n}\n\n// * Using Hashing( But not for larg and negative numbers)\n\nint hashApproach(int arr[], int n)\n{\n  int max = 0;\n  for (int i = 0; i < n; i++)\n  {\n    if (max < arr[i])\n    {\n      max = arr[i];\n    }\n  }\n  int hash[max + 1];\n  for (int i = 0; i < max + 1; i++)\n    hash[i] = 0;\n  for (int i = 0; i < n; i++)\n  {\n    hash[arr[i]]++;\n  }\n  for (int i = 0; i < n; i++)\n  {\n    if (hash[arr[i]] == 1)\n      return arr[i];\n  }\n  return -1;\n}\n\n//* Using map<long long, int>\n\nint mapApproach(int arr[], int n)\n{\n  map<long long, int> mpp;\n  for (int i = 0; i < n; i++)\n  {\n    mpp[arr[i]]++;\n  }\n\n  for (auto it : mpp)\n  {\n    if (it.second == 1)\n      return it.first;\n  }\n\n  return -1;\n}\n\n//* Using XOR\n\nint xorApproch(int arr[], int n)\n{\n  int XOR = 0;\n  for (int i = 0; i < n; i++)\n  {\n    XOR = XOR ^ arr[i];\n  }\n  return XOR;\n}\n\nvoid testCase(int arr[], int n, int expected, string testName)\n{\n  cout << \"\\n=== \" << testName << \" ===\" << endl;\n  cout << \"Input: \";\n  for (int i = 0; i < n; i++)\n    cout << arr[i] << \" \";\n  cout << endl;\n\n  cout << \"Expected: \" << expected << endl;\n  cout << \"BruteReturn: \" << BruteReturn(arr, n) << endl;\n  cout << \"hashApproach: \" << hashApproach(arr, n) << endl;\n  cout << \"mapApproach: \" << mapApproach(arr, n) << endl;\n  cout << \"xorApproach: \" << xorApproch(arr, n) << endl;\n}\n\nint main()\n{\n  // Test Case 1\n  int arr1[] = {2, 2, 1, 3, 3};\n  testCase(arr1, 5, 1, \"Basic Case\");\n\n  // Test Case 2\n  int arr2[] = {7, 1, 1, 2, 2};\n  testCase(arr2, 5, 7, \"Unique at Start\");\n\n  // Test Case 3\n  int arr3[] = {1, 1, 2, 2, 9};\n  testCase(arr3, 5, 9, \"Unique at End\");\n\n  return 0;\n}"
    },
    {
      "name": "Find The Missing Number",
      "filename": "FindTheMissingNumber.c++",
      "path": "practices/Arrays/Easy/FindTheMissingNumber.c++",
      "content": "#include <iostream>\nusing namespace std;\n\n//* Brute froce\n//  Time Complexity: O(N2)\n// Space Complexity: O(1)\nint BruteFindMissing(int arr[], int n)\n{\n  for (int i = 1; i <= n; i++)\n  {\n    int flag = 0;\n    for (int j = 0; j < n; j++)\n    {\n      if (arr[j] == i)\n      {\n        flag = 1;\n        break;\n      }\n    }\n    if (flag == 0)\n      return i;\n  }\n  return -1;\n}\n\n// * Better Approach\n// Time Complexity: O(N) + O(N) ~ O(2*N)\n// Space Complexity: O(N)\nint BetterFindMissing(int arr[], int n)\n{\n  int hash[n + 2]; // the hash[0] should always 0;\n\n  for (int i = 0; i < n + 2; i++)\n  {\n    hash[i] = 0;\n  }\n  // storing the frequencies:\n  for (int i = 0; i < n; i++)\n  {\n    if (arr[i] >= 0 && arr[i] <= n + 1) // * Bound Check\n      hash[arr[i]]++;\n  }\n  for (int i = 1; i < n + 1; i++)\n  {\n    if (hash[i] == 0)\n      return i;\n  }\n  return -1;\n}\n\n// * Optimal_1 (Using Sum) not For Long(sum = N(N+1) / 2;\nint sumFindMissing(int arr[], int n)\n{\n  int sum1 = (n + 1) * (n + 2) / 2;\n  int sum2 = 0;\n  for (int i = 0; i < n; i++)\n  {\n    sum2 += arr[i];\n  }\n  int result = sum1 - sum2;\n  return result;\n}\n\n//* Optimal_2 (Using XOR)\nint xorFindMissing(int arr[], int n)\n{\n  int Xor1 = 0;\n  int Xor2 = 0;\n  for (int i = 0; i < n; i++)\n  {\n    Xor2 = Xor2 ^ arr[i];\n    Xor1 = Xor1 ^ (i + 1);\n  }\n  Xor1 = Xor1 ^ n + 1;\n  int result = Xor1 ^ Xor2;\n  return result;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  int arr[n];\n  for (int i = 0; i < n; i++)\n    cin >> arr[i];\n  // cout << \"Missing number is :\" << BruteFindMissing(arr, n);\n  // cout << \"Missing number is :\" << BetterFindMissing(arr, n);\n  // cout << \"Missing number is :\" << sumFindMissing(arr, n);\n  cout << \"Missing number is :\" << xorFindMissing(arr, n);\n\n  return 0;\n}"
    },
    {
      "name": "insertsect Of Two Array",
      "filename": "insertsectOfTwoArray.c++",
      "path": "practices/Arrays/Easy/insertsectOfTwoArray.c++",
      "content": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// * sample inPut\n// 5\n// 1 2 3 4 5\n// 5\n// 3 4 5 6 7\n// *\n// 6\n// 1 2 2 3 3 3\n// 5\n// 2 2 3 4 4\n\n/*\n * Function to find intersection of two arrays\n * Returns a vector containing common elements\n *\n * Approach 1: Brute Force\n * Time Complexity: O(n*m)\n * Space Complexity: O(1) - excluding result array\n */\nvector<int> intersectionBruteForce(vector<int> &arr1, vector<int> &arr2)\n{\n  vector<int> result;\n  vector<bool> used(arr2.size(), false);\n  for (int i = 0; i < arr1.size(); i++)\n  {\n    for (int j = 0; j < arr2.size(); j++)\n    {\n      if (arr1[i] == arr2[j] && used[j] == false)\n      {\n\n        result.push_back(arr1[i]);\n        used[j] = true;\n        break; // Move to next element in arr1\n      }\n    }\n  }\n  return result;\n}\n/*\n * Function to find intersection of two sorted arrays\n * Using Two Pointer Approach\n *\n * Time Complexity: O(n+m)\n * Space Complexity: O(1) - excluding result array\n */\nvector<int> intersectionTwoPointer(vector<int> &arr1, vector<int> &arr2)\n{\n  vector<int> result;\n  int i = 0, j = 0;\n  int n = arr1.size(), m = arr2.size();\n\n  while (i < n && j < m)\n  {\n    if (arr1[i] == arr2[j])\n    {\n      result.push_back(arr1[i]);\n      i++; // Advance both pointers\n      j++; // when elements are equal\n    }\n    else if (arr1[i] < arr2[j]) // arr1[i] is smaller\n    {\n      i++; // Move to next element in arr1\n    }\n    else // arr1[i] > arr2[j], arr2[j] is smaller\n    {\n      j++; // Move to next element in arr2\n    }\n  }\n\n  return result;\n}\n\n/*\n * Helper function to print vector elements\n */\nvoid printVector(const vector<int> &arr)\n{\n  cout << \"[\";\n  for (int i = 0; i < arr.size(); i++)\n  {\n    cout << arr[i];\n    if (i < arr.size() - 1)\n      cout << \", \";\n  }\n  cout << \"]\" << endl;\n}\n\n/*\n * Helper function to input array elements\n */\nvector<int> inputArray(int size)\n{\n  vector<int> arr(size);\n  cout << \"Enter \" << size << \" elements: \";\n  for (int i = 0; i < size; i++)\n  {\n    cin >> arr[i];\n  }\n  return arr;\n}\n\nint main()\n{\n  cout << \"=== Array Intersection Program ===\" << endl;\n\n  // Input first array\n  cout << \"\\nFirst Array:\" << endl;\n  cout << \"Enter size: \";\n  int n1;\n  cin >> n1;\n  vector<int> arr1 = inputArray(n1);\n\n  // Input second array\n  cout << \"\\nSecond Array:\" << endl;\n  cout << \"Enter size: \";\n  int n2;\n  cin >> n2;\n  vector<int> arr2 = inputArray(n2);\n\n  // Display input arrays\n  cout << \"\\nArray 1: \";\n  printVector(arr1);\n  cout << \"Array 2: \";\n  printVector(arr2);\n\n  // Test brute force approach\n  cout << \"\\n--- Brute Force Approach ---\" << endl;\n  vector<int> result1 = intersectionBruteForce(arr1, arr2);\n  cout << \"Intersection: \";\n  printVector(result1);\n\n  // Sort arrays for two pointer approach\n  sort(arr1.begin(), arr1.end());\n  sort(arr2.begin(), arr2.end());\n\n  cout << \"\\n--- Two Pointer Approach (on sorted arrays) ---\" << endl;\n  cout << \"Sorted Array 1: \";\n  printVector(arr1);\n  cout << \"Sorted Array 2: \";\n  printVector(arr2);\n\n  vector<int> result2 = intersectionTwoPointer(arr1, arr2);\n  cout << \"Intersection: \";\n  printVector(result2);\n\n  return 0;\n}\n\n/*\n * Example Test Cases:\n *\n * Test Case 1:\n * Array 1: [1, 2, 2, 1]\n * Array 2: [2, 2]\n * Expected Output: [2, 2] or [2] (depending on if duplicates allowed)\n *\n * Test Case 2:\n * Array 1: [4, 9, 5]\n * Array 2: [9, 4, 9, 8, 4]\n * Expected Output: [4, 9] or [9, 4]\n *\n * Test Case 3:\n * Array 1: [1, 2, 3]\n * Array 2: [4, 5, 6]\n * Expected Output: [] (empty)\n */"
    },
    {
      "name": "is Sorted",
      "filename": "isSorted.c++",
      "path": "practices/Arrays/Easy/isSorted.c++",
      "content": "#include <iostream>\nusing namespace std;\n\nbool check(int nums[], int n)\n{\n  int count = 0;\n  for (int i = 0; i < n - 1; i++)\n  {\n    if (nums[i] > nums[(i + 1)])\n      count++;\n  }\n\n  return count == 0;\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  int arr[n];\n  for (int i = 0; i < n; i++)\n    cin >> arr[i];\n  if (check(arr, n))\n    cout << \"Array is sorted\";\n  else\n    cout << \"Not Sorted\";\n\n  return 0;\n}"
    },
    {
      "name": "Linear Search",
      "filename": "LinearSearch.c++",
      "path": "practices/Arrays/Easy/LinearSearch.c++",
      "content": "#include <iostream>\nusing namespace std;\nint linerSearch(int arr[], int n, int key)\n{\n  for (int i = 0; i < n; i++)\n  {\n    if (arr[i] == key)\n    {\n      return i;\n    }\n  }\n  return -1;\n}\n\nint main()\n{\n  int n, key;\n  cin >> n;\n  int arr[n];\n  for (int i = 0; i < n; i++)\n    cin >> arr[i];\n  cin >> key;\n  cout << \"at Index : \" << linerSearch(arr, n, key);\n  return 0;\n}"
    },
    {
      "name": "Longest Subarray With Given Sum K",
      "filename": "LongestSubarrayWithGivenSumK.c++",
      "path": "practices/Arrays/Easy/LongestSubarrayWithGivenSumK.c++",
      "content": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\n// * Brute Force\n// TC : O(n^2)\n// SC : O(1)\nvector<int> subArray(int arr[], int n, int k)\n{\n  pair<int, int> p = {-1, -1};\n  int maxLength = 0;\n\n  for (int i = 0; i < n; i++)\n  {\n    int Sum = 0;\n    for (int j = i; j < n; j++)\n    {\n      Sum += arr[j];\n      if (Sum == k)\n      {\n        int currentLength = j - i + 1;\n        if (maxLength < currentLength)\n        {\n          maxLength = currentLength;\n          p = {i, j};\n        }\n      }\n      else if (Sum > k)\n      {\n        break;\n      }\n    }\n  }\n  return {p.first, p.second};\n}\n\n// * Using Hashing\n// TC : O(n)\n// SC : O(n)\nvector<int> usingHash(int arr[], int n, int k)\n{\n  map<int, int> mpp;\n  int maxLen = 0;\n  int sum = 0;\n  int startIdx = -1, endIdx = -1;\n\n  for (int i = 0; i < n; i++)\n  {\n    sum += arr[i];\n\n    if (sum == k)\n    {\n      if (maxLen < i + 1)\n      {\n        maxLen = i + 1;\n        startIdx = 0;\n        endIdx = i;\n      }\n    }\n\n    int rem = sum - k;\n    if (mpp.find(rem) != mpp.end())\n    {\n      int len = i - mpp[rem];\n      if (maxLen < len)\n      {\n        maxLen = len;\n        startIdx = mpp[rem] + 1;\n        endIdx = i;\n      }\n    }\n\n    if (mpp.find(sum) == mpp.end())\n    {\n      mpp[sum] = i;\n    }\n  }\n\n  return {startIdx, endIdx};\n}\n\n// * Optimal Sol only for Positive and 0's (Two Pointer/Slidding Window)\n// TC : O(2n)\n// SC : O(1)\nvector<int> Optimal(int arr[], int n, int k)\n{\n  int left = 0, right = 0;\n  int sum = 0;\n  int maxLen = 0;\n  int startIdx = -1, endIdx = -1;\n\n  while (right < n)\n  {\n    sum += arr[right];\n\n    while (sum > k && left <= right)\n    {\n      sum -= arr[left];\n      left++;\n    }\n\n    if (sum == k)\n    {\n      int currentLen = right - left + 1;\n      if (currentLen > maxLen)\n      {\n        maxLen = currentLen;\n        startIdx = left;\n        endIdx = right;\n      }\n    }\n\n    right++;\n  }\n\n  return {startIdx, endIdx};\n}\n\nvoid runTestCase(int testNum, int arr[], int n, int k, string method = \"Brute Force\")\n{\n  cout << \"\\n--- Test Case \" << testNum << \" (\" << method << \") ---\" << endl;\n  cout << \"Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << \"\\nTarget Sum: \" << k << endl;\n\n  vector<int> result;\n  if (method == \"Brute Force\")\n    result = subArray(arr, n, k);\n  else if (method == \"Hashing\")\n    result = usingHash(arr, n, k);\n  else if (method == \"Optimal\")\n    result = Optimal(arr, n, k);\n\n  if (result[0] == -1)\n  {\n    cout << \"No subarray found with sum \" << k << endl;\n  }\n  else\n  {\n    int length = result[1] - result[0] + 1;\n    cout << \"Longest subarray found at indices [\" << result[0] << \", \" << result[1]\n         << \"] with length \" << length << endl;\n    cout << \"Elements: \";\n    for (int i = result[0]; i <= result[1]; i++)\n    {\n      cout << arr[i];\n      if (i < result[1])\n        cout << \" + \";\n    }\n    cout << \" = \" << k << endl;\n  }\n}\n\nint main()\n{\n  cout << \"=== COMPARING ALL THREE METHODS ===\" << endl;\n\n  // Test Case 1: Your specific test case\n  int arr1[] = {1, 2, 2, 1, 1, 1, 1, 2};\n  cout << \"\\n>> Test with array {1, 2, 2, 1, 1, 1, 1, 2} and k=4:\" << endl;\n  runTestCase(1, arr1, 8, 4, \"Brute Force\");\n  runTestCase(1, arr1, 8, 4, \"Hashing\");\n  runTestCase(1, arr1, 8, 4, \"Optimal\");\n\n  // Test Case 2: Multiple consecutive 1's\n  int arr2[] = {1, 1, 1, 1, 1, 1};\n  cout << \"\\n>> Test with array {1, 1, 1, 1, 1, 1} and k=3:\" << endl;\n  runTestCase(2, arr2, 6, 3, \"Brute Force\");\n  runTestCase(2, arr2, 6, 3, \"Hashing\");\n  runTestCase(2, arr2, 6, 3, \"Optimal\");\n\n  // Test Case 3: Normal case\n  int arr3[] = {1, 2, 3, 4, 5};\n  cout << \"\\n>> Test with array {1, 2, 3, 4, 5} and k=9:\" << endl;\n  runTestCase(3, arr3, 5, 9, \"Brute Force\");\n  runTestCase(3, arr3, 5, 9, \"Hashing\");\n  runTestCase(3, arr3, 5, 9, \"Optimal\");\n\n  // Test Case 4: Single element\n  int arr4[] = {5};\n  cout << \"\\n>> Test with array {5} and k=5:\" << endl;\n  runTestCase(4, arr4, 1, 5, \"Brute Force\");\n  runTestCase(4, arr4, 1, 5, \"Hashing\");\n  runTestCase(4, arr4, 1, 5, \"Optimal\");\n\n  // Test Case 5: No solution\n  int arr5[] = {1, 2, 3, 4};\n  cout << \"\\n>> Test with array {1, 2, 3, 4} and k=15:\" << endl;\n  runTestCase(5, arr5, 4, 15, \"Brute Force\");\n  runTestCase(5, arr5, 4, 15, \"Hashing\");\n  runTestCase(5, arr5, 4, 15, \"Optimal\");\n\n  return 0;\n}\n"
    },
    {
      "name": "Max One",
      "filename": "MaxOne.c++",
      "path": "practices/Arrays/Easy/MaxOne.c++",
      "content": "#include <vector>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n\nint findMaxConsecutiveOnes(vector<int> &nums)\n{\n  int maxC = 0;\n  int cnt = 0;\n  for (int i = 0; i < nums.size(); i++)\n  {\n    if (nums[i] == 1)\n    {\n      cnt++;\n      maxC = max(cnt, maxC);\n    }\n    else\n      cnt = 0;\n  }\n  return maxC;\n}\n\nint main()\n{\n  // Test cases\n  vector<int> nums1 = {1, 1, 0, 1, 1, 1};\n  vector<int> nums2 = {1, 0, 1, 1, 0, 1};\n  vector<int> nums3 = {0, 0, 0, 0};\n  vector<int> nums4 = {1, 1, 1, 1};\n\n  cout << \"Test 1: \" << findMaxConsecutiveOnes(nums1) << \" (Expected: 3)\" << endl;\n  cout << \"Test 2: \" << findMaxConsecutiveOnes(nums2) << \" (Expected: 2)\" << endl;\n  cout << \"Test 3: \" << findMaxConsecutiveOnes(nums3) << \" (Expected: 0)\" << endl;\n  cout << \"Test 4: \" << findMaxConsecutiveOnes(nums4) << \" (Expected: 4)\" << endl;\n\n  return 0;\n}"
    },
    {
      "name": "Move Zerosto End",
      "filename": "MoveZerostoEnd.c++",
      "path": "practices/Arrays/Easy/MoveZerostoEnd.c++",
      "content": "#include <iostream>\nusing namespace std;\n\n/*\n * Function to move all zeros to the end of array while maintaining\n * the relative order of non-zero elements\n *\n * Algorithm: Two-Pass Approach\n * Pass 1: Move all non-zero elements to the front\n * Pass 2: Fill remaining positions with zeros\n *\n * Example: [0,1,0,3,12] becomes [1,3,12,0,0]\n *\n * Time Complexity: O(n) - two passes through array\n * Space Complexity: O(1) - in-place modification\n */\nvoid moveZerosToEnd(int arr[], int n)\n{\n  int nonZero = 0; // Pointer to track position for next non-zero element\n\n  // PASS 1: Move all non-zero elements to the front\n  // Copy non-zero elements to positions 0, 1, 2, ...\n  for (int i = 0; i < n; i++)\n  {\n    if (arr[i] != 0)\n    {\n      arr[nonZero] = arr[i]; // Place non-zero element at front\n      nonZero++;             // Move to next position for non-zero element\n    }\n    // If arr[i] is 0, we skip it (don't copy)\n  }\n\n  // PASS 2: Fill remaining positions with zeros\n  // After copying all non-zero elements, fill rest with 0s\n  while (nonZero < n)\n  {\n    arr[nonZero] = 0; // Fill with zero\n    nonZero++;        // Move to next position\n  }\n}\n\n// * Using Two Pointer Approach\n// TC: O(n)\n// SC: O(1);\nvoid pointerMoveZerosToEnd(int arr[], int n)\n{\n  int j = -1, i = 0;\n  for (int i = 0; i < n; i++)\n  {\n    if (arr[i] == 0)\n    {\n      j = i;\n      break;\n    }\n  }\n  if (j == -1)\n    return;\n  for (int i = j + 1; i < n; i++)\n  {\n    if (arr[i] != 0)\n    {\n      swap(arr[i], arr[j]);\n      j++;\n    }\n  }\n}\n\n/*\n * Helper function to print array elements\n */\nvoid printArray(int arr[], int n)\n{\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i];\n    if (i < n - 1)\n      cout << \" \"; // Add space between elements\n  }\n  cout << endl;\n}\n\nint main()\n{\n  cout << \"Enter the size of array: \";\n  int n;\n  cin >> n;\n\n  int arr[n];\n  cout << \"Enter \" << n << \" elements: \";\n  for (int i = 0; i < n; i++)\n    cin >> arr[i];\n\n  cout << \"\\nOriginal array: \";\n  printArray(arr, n);\n\n  // Move all zeros to the end\n  // moveZerosToEnd(arr, n);\n  pointerMoveZerosToEnd(arr, n);\n\n  cout << \"After moving zeros to end: \";\n  printArray(arr, n);\n\n  return 0;\n}\n\n/*\n * Step-by-Step Example:\n * Input: [0, 1, 0, 3, 12]\n *\n * PASS 1 - Moving non-zero elements to front:\n * i=0: arr[0]=0 ‚Üí skip (zero)\n * i=1: arr[1]=1 ‚Üí arr[0]=1, nonZero=1 ‚Üí [1, 1, 0, 3, 12]\n * i=2: arr[2]=0 ‚Üí skip (zero)\n * i=3: arr[3]=3 ‚Üí arr[1]=3, nonZero=2 ‚Üí [1, 3, 0, 3, 12]\n * i=4: arr[4]=12 ‚Üí arr[2]=12, nonZero=3 ‚Üí [1, 3, 12, 3, 12]\n *\n * PASS 2 - Filling remaining with zeros:\n * nonZero=3: arr[3]=0 ‚Üí [1, 3, 12, 0, 12]\n * nonZero=4: arr[4]=0 ‚Üí [1, 3, 12, 0, 0]\n *\n * Final Result: [1, 3, 12, 0, 0]\n *\n * Alternative Single-Pass Approach (Advanced):\n * Use two pointers - one for non-zero position, one for scanning.\n * When found non-zero, swap with non-zero position pointer.\n */"
    },
    {
      "name": "Remove Duplicate",
      "filename": "RemoveDuplicate.c++",
      "path": "practices/Arrays/Easy/RemoveDuplicate.c++",
      "content": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n/*\n * Function to remove duplicates from a sorted array in-place\n *\n * Algorithm: Two Pointer Technique\n * - Pointer 'i': tracks the position of last unique element\n * - Pointer 'j': scans through the array to find next unique element\n *\n * Logic:\n * - Start with i=0 (first element is always unique)\n * - Compare arr[i] with arr[j] for j from 1 to n-1\n * - If different, move arr[j] to position i+1 and increment i\n * - Return i+1 (count of unique elements)\n *\n * Example: [1,1,2,2,3,3,4] becomes [1,2,3,4,_,_,_] and returns 4\n */\nint removeDuplicates(vector<int> &arr)\n{\n  // Handle edge case: empty array\n  if (arr.size() == 0)\n    return 0;\n\n  int i = 0; // Pointer to track last unique element position\n\n  // Scan through array starting from second element\n  for (int j = 1; j < arr.size(); j++)\n  {\n    // If current element is different from last unique element\n    if (arr[i] != arr[j])\n    {\n      // Move unique element to next position\n      i++;             // Move to next unique position\n      arr[i] = arr[j]; // Place the unique element (no swapping needed)\n    }\n    // If arr[i] == arr[j], it's a duplicate, so skip it\n  }\n\n  return i + 1; // Return count of unique elements\n}\n\n/*\n * Helper function to print array elements\n */\nvoid printArray(vector<int> &arr, int length)\n{\n  cout << \"Array: \";\n  for (int i = 0; i < length; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n}\n\nint main()\n{\n  cout << \"Enter the size of sorted array: \";\n  int n;\n  cin >> n;\n\n  vector<int> arr(n);\n  cout << \"Enter \" << n << \" sorted elements: \";\n  for (int i = 0; i < n; i++)\n  {\n    cin >> arr[i];\n  }\n\n  cout << \"\\nOriginal array: \";\n  printArray(arr, n);\n\n  // Remove duplicates and get count of unique elements\n  int uniqueCount = removeDuplicates(arr);\n\n  cout << \"After removing duplicates: \";\n  printArray(arr, uniqueCount);\n\n  cout << \"Number of unique elements: \" << uniqueCount << endl;\n\n  return 0;\n}\n\n/*\n * Example Walkthrough:\n * Input: [1, 1, 2, 2, 3, 3, 4]\n *\n * Initial: i=0, arr=[1,1,2,2,3,3,4]\n * j=1: arr[0]=1, arr[1]=1 ‚Üí same, skip\n * j=2: arr[0]=1, arr[2]=2 ‚Üí different, i=1, arr[1]=2 ‚Üí [1,2,2,2,3,3,4]\n * j=3: arr[1]=2, arr[3]=2 ‚Üí same, skip\n * j=4: arr[1]=2, arr[4]=3 ‚Üí different, i=2, arr[2]=3 ‚Üí [1,2,3,2,3,3,4]\n * j=5: arr[2]=3, arr[5]=3 ‚Üí same, skip\n * j=6: arr[2]=3, arr[6]=4 ‚Üí different, i=3, arr[3]=4 ‚Üí [1,2,3,4,3,3,4]\n *\n * Result: [1,2,3,4,...] with 4 unique elements\n *\n * Time Complexity: O(n) - single pass through array\n * Space Complexity: O(1) - in-place modification\n */\n"
    },
    {
      "name": "replace With Greatest Right",
      "filename": "replaceWithGreatestRight.c++",
      "path": "practices/Arrays/Easy/replaceWithGreatestRight.c++",
      "content": "/*\nProblem: Replace Elements with Greatest Element on Right Side\n\nDescription:\nGiven an array arr, replace every element in that array with the greatest element\namong the elements to its right, and replace the last element with -1.\n\nAfter doing so, return the array.\n\nExample 1:\nInput: arr = [17,18,5,4,6,1]\nOutput: [18,6,6,6,1,-1]\nExplanation:\n- index 0 --> the greatest element to the right of index 0 is index 1 (18).\n- index 1 --> the greatest element to the right of index 1 is index 4 (6).\n- index 2 --> the greatest element to the right of index 2 is index 4 (6).\n- index 3 --> the greatest element to the right of index 3 is index 4 (6).\n- index 4 --> the greatest element to the right of index 4 is index 5 (1).\n- index 5 --> there are no elements to the right of index 5, so we put -1.\n\nExample 2:\nInput: arr = [400]\nOutput: [-1]\nExplanation: There are no elements to the right of index 0.\n\nConstraints:\n- 1 <= arr.length <= 10^4\n- 1 <= arr[i] <= 10^5\n\nTime Complexity: O(n)\nSpace Complexity: O(1)\n*/\n\n#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n// Brute Force\n// class Solution\n// {\n// public:\n//   vector<int> replaceElements(vector<int> &arr)\n//   {\n//     vector<int> ans;\n//     for (int i = 0; i < arr.size(); i++)\n//     {\n//       int grt = -1;\n//       for (int j = i + 1; j < arr.size(); j++)\n//       {\n//         grt = max(grt, arr[j]);\n//       }\n//       ans.push_back(grt);\n//     }\n//     return ans;\n//   }\n// };\n\n// Suffix Max\nclass Solution\n{\npublic:\n  vector<int> replaceElements(vector<int> &arr)\n  {\n    int n = arr.size();\n    vector<int> ans(n);\n    int rightMax = -1;\n    for (int i = n - 1; i >= 0; i--)\n    {\n      ans[i] = rightMax;\n      rightMax = max(rightMax, arr[i]);\n    }\n    return ans;\n  }\n};\n\n// Test cases\nvoid runTests()\n{\n  Solution sol;\n\n  // Test Case 1\n  vector<int> arr1 = {17, 18, 5, 4, 6, 1};\n  vector<int> expected1 = {18, 6, 6, 6, 1, -1};\n  vector<int> result1 = sol.replaceElements(arr1);\n  cout << \"Test 1:\" << endl;\n  cout << \"Expected: [\";\n  for (int i = 0; i < expected1.size(); i++)\n  {\n    cout << expected1[i];\n    if (i < expected1.size() - 1)\n      cout << \", \";\n  }\n  cout << \"]\" << endl;\n  cout << \"Output:   [\";\n  for (int i = 0; i < result1.size(); i++)\n  {\n    cout << result1[i];\n    if (i < result1.size() - 1)\n      cout << \", \";\n  }\n  cout << \"]\" << endl\n       << endl;\n\n  // Test Case 2\n  vector<int> arr2 = {400};\n  vector<int> expected2 = {-1};\n  vector<int> result2 = sol.replaceElements(arr2);\n  cout << \"Test 2:\" << endl;\n  cout << \"Expected: [\";\n  for (int i = 0; i < expected2.size(); i++)\n  {\n    cout << expected2[i];\n    if (i < expected2.size() - 1)\n      cout << \", \";\n  }\n  cout << \"]\" << endl;\n  cout << \"Output:   [\";\n  for (int i = 0; i < result2.size(); i++)\n  {\n    cout << result2[i];\n    if (i < result2.size() - 1)\n      cout << \", \";\n  }\n  cout << \"]\" << endl\n       << endl;\n\n  // Test Case 3: Two elements\n  vector<int> arr3 = {1, 2};\n  vector<int> expected3 = {2, -1};\n  vector<int> result3 = sol.replaceElements(arr3);\n  cout << \"Test 3:\" << endl;\n  cout << \"Expected: [\";\n  for (int i = 0; i < expected3.size(); i++)\n  {\n    cout << expected3[i];\n    if (i < expected3.size() - 1)\n      cout << \", \";\n  }\n  cout << \"]\" << endl;\n  cout << \"Output:   [\";\n  for (int i = 0; i < result3.size(); i++)\n  {\n    cout << result3[i];\n    if (i < result3.size() - 1)\n      cout << \", \";\n  }\n  cout << \"]\" << endl\n       << endl;\n\n  // Test Case 4: Decreasing array\n  vector<int> arr4 = {5, 4, 3, 2, 1};\n  vector<int> expected4 = {4, 3, 2, 1, -1};\n  vector<int> result4 = sol.replaceElements(arr4);\n  cout << \"Test 4:\" << endl;\n  cout << \"Expected: [\";\n  for (int i = 0; i < expected4.size(); i++)\n  {\n    cout << expected4[i];\n    if (i < expected4.size() - 1)\n      cout << \", \";\n  }\n  cout << \"]\" << endl;\n  cout << \"Output:   [\";\n  for (int i = 0; i < result4.size(); i++)\n  {\n    cout << result4[i];\n    if (i < result4.size() - 1)\n      cout << \", \";\n  }\n  cout << \"]\" << endl\n       << endl;\n\n  // Test Case 5: All same elements\n  vector<int> arr5 = {3, 3, 3, 3};\n  vector<int> expected5 = {3, 3, 3, -1};\n  vector<int> result5 = sol.replaceElements(arr5);\n  cout << \"Test 5:\" << endl;\n  cout << \"Expected: [\";\n  for (int i = 0; i < expected5.size(); i++)\n  {\n    cout << expected5[i];\n    if (i < expected5.size() - 1)\n      cout << \", \";\n  }\n  cout << \"]\" << endl;\n  cout << \"Output:   [\";\n  for (int i = 0; i < result5.size(); i++)\n  {\n    cout << result5[i];\n    if (i < result5.size() - 1)\n      cout << \", \";\n  }\n  cout << \"]\" << endl\n       << endl;\n}\n\nint main()\n{\n  runTests();\n  return 0;\n}\n"
    },
    {
      "name": "Rotated Array",
      "filename": "RotatedArray.c++",
      "path": "practices/Arrays/Easy/RotatedArray.c++",
      "content": "\n/*\n * ===============================================================================\n * üîÑ ARRAY ROTATION - COMPREHENSIVE EDUCATIONAL GUIDE\n * ===============================================================================\n *\n * üéØ PROBLEM STATEMENT:\n * Given an array and a number k, rotate the array to the right by k positions.\n * Each element moves k positions to the right, wrapping around to the beginning.\n *\n * üìä DIFFICULTY: Medium (Perfect for learning array manipulation)\n * ‚è±Ô∏è  TIME TO LEARN: 15-20 minutes\n *\n * üß† KEY LEARNING CONCEPTS:\n * ‚Ä¢ Array indexing and modular arithmetic\n * ‚Ä¢ Trade-offs between time and space complexity\n * ‚Ä¢ In-place vs auxiliary space algorithms\n * ‚Ä¢ Mathematical optimization techniques\n *\n */\n\n#include <iostream>\n#include <algorithm> // For reverse() function used in optimized method\nusing namespace std;\n\n// Sample Input\n// 6 3\n// 2 3 4 5 6 7\n// Expected Output: 5 6 7 2 3 4\n\n/**\n * üîÑ METHOD 1: Using Extra Space (Easier to understand)\n * Think: Create a new arrangement, then copy it back\n *\n * @param arr: Array to rotate\n * @param n: Array size\n * @param k: Number of positions to rotate right\n */\nvoid rotatedArray(int arr[], int n, int k)\n{\n  // üõ°Ô∏è Handle cases where k > n (e.g., k=8, n=6 ‚Üí k=2)\n  k = k % n;\n\n  // üì¶ Create temporary array to store new arrangement\n  int temp[n];\n\n  // üîÑ Place each element in its new rotated position\n  for (int i = 0; i < n; i++)\n  {\n    // Formula: new_position = (current_position + k) % n\n    temp[(i + k) % n] = arr[i];\n  }\n\n  // üìã Copy the new arrangement back to original array\n  for (int i = 0; i < n; i++)\n  {\n    arr[i] = temp[i];\n  }\n}\n\n/**\n * üîÑ METHOD 2: Space Optimized (Advanced technique)\n * Think: Use three reversals to achieve rotation\n *\n * Magic Formula: To rotate right by k:\n * 1. Reverse entire array\n * 2. Reverse first k elements\n * 3. Reverse remaining n-k elements\n *\n * @param arr: Array to rotate\n * @param n: Array size\n * @param k: Number of positions to rotate right\n */\nvoid rotatedArrayOptimized(int arr[], int n, int k)\n{\n  k = k % n; // Handle k > n\n\n  // Step 1: Reverse entire array\n  reverse(arr, arr + n);\n\n  // Step 2: Reverse first k elements\n  reverse(arr, arr + k);\n\n  // Step 3: Reverse remaining n-k elements\n  reverse(arr + k, arr + n);\n}\n\nint main()\n{\n  int n, k;\n  cout << \"Enter array size and rotation count: \";\n  cin >> n >> k;\n\n  int arr[n];\n  cout << \"Enter \" << n << \" elements: \";\n  for (int i = 0; i < n; i++)\n  {\n    cin >> arr[i];\n  }\n\n  // Show original array\n  cout << \"\\nOriginal Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n\n  // Choose one method (comment out the other)\n  rotatedArray(arr, n, k); // Method 1: Extra space\n  // rotatedArrayOptimized(arr, n, k);  // Method 2: No extra space\n\n  cout << \"\\nRotated Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}\n// * üîÑ Method 2 : Three Reversals\n// Original: [2, 3, 4, 5, 6, 7]\n\n// Step 1: Reverse entire array\n// [2, 3, 4, 5, 6, 7] ‚Üí [7, 6, 5, 4, 3, 2]\n\n// Step 2: Reverse first k=3 elements\n// [7, 6, 5, 4, 3, 2] ‚Üí [5, 6, 7, 4, 3, 2]\n//  -------              -------\n// reverse these         reversed!\n\n// Step 3: Reverse remaining n-k=3 elements\n// [5, 6, 7, 4, 3, 2] ‚Üí [5, 6, 7, 2, 3, 4]\n//           -------              -------\n//           reverse              reversed!\n\n// Final: [5, 6, 7, 2, 3, 4] ‚úÖ\n\n// * üîÑ Method 1 : Using Extra Space\n//  Original: [2, 3, 4, 5, 6, 7]\n//  Position:  0  1  2  3  4  5\n\n// Step 1: Calculate new positions (shift right by 3)\n// arr[0] = 2 ‚Üí goes to position (0+3)%6 = 3\n// arr[1] = 3 ‚Üí goes to position (1+3)%6 = 4\n// arr[2] = 4 ‚Üí goes to position (2+3)%6 = 5\n// arr[3] = 5 ‚Üí goes to position (3+3)%6 = 0  ‚Üê wraps around!\n// arr[4] = 6 ‚Üí goes to position (4+3)%6 = 1  ‚Üê wraps around!\n// arr[5] = 7 ‚Üí goes to position (5+3)%6 = 2  ‚Üê wraps around!\n\n// Step 2: temp array becomes:\n// Position: [0, 1, 2, 3, 4, 5]\n// temp:     [5, 6, 7, 2, 3, 4]\n\n// Step 3: Copy back to original\n// Result: [5, 6, 7, 2, 3, 4]\n/**\n * ‚ö° COMPREHENSIVE PERFORMANCE & LEARNING ANALYSIS\n *\n * üìä METHOD COMPARISON TABLE:\n * ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n * ‚îÇ Method          ‚îÇ Time     ‚îÇ Space   ‚îÇ Difficulty  ‚îÇ Best Use Case   ‚îÇ\n * ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n * ‚îÇ Extra Space     ‚îÇ O(n)     ‚îÇ O(n)    ‚îÇ Easy üòä     ‚îÇ Learning/Debug  ‚îÇ\n * ‚îÇ Three Reversals ‚îÇ O(n)     ‚îÇ O(1)    ‚îÇ Medium ü§î   ‚îÇ Interviews/Prod ‚îÇ\n * ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n *\n * üéØ WHEN TO USE WHICH METHOD:\n *\n * üìñ Method 1 (Extra Space) - Choose when:\n * ‚úÖ Learning array concepts for the first time\n * ‚úÖ Code readability is more important than memory\n * ‚úÖ Working with small arrays (memory not a concern)\n * ‚úÖ Need to preserve original array for comparison\n * ‚ùå Avoid when: Memory is limited or array is very large\n *\n * üöÄ Method 2 (Three Reversals) - Choose when:\n * ‚úÖ Memory optimization is crucial\n * ‚úÖ In technical interviews (shows advanced thinking)\n * ‚úÖ Working with large datasets\n * ‚úÖ Need in-place modification\n * ‚ùå Avoid when: Code simplicity is priority over optimization\n *\n * üß© WHY THREE REVERSALS WORK - The Magic Explained:\n * Think backwards! To get last k elements at front:\n * 1. Put entire array backwards ‚Üí last elements come first\n * 2. Fix order of first k elements ‚Üí correct front part\n * 3. Fix order of remaining elements ‚Üí correct back part\n * Result: Perfect rotation achieved with just reversals!\n **/"
    },
    {
      "name": "Scoreof String",
      "filename": "ScoreofString.c++",
      "path": "practices/Arrays/Easy/ScoreofString.c++",
      "content": "#include <iostream>\n#include <string>\nusing namespace std;\n\n// Optimized function - clean and reusable\nint scoreOfString(const string &s)\n{\n  if (s.length() < 2)\n    return 0; // Edge case handling\n\n  int score = 0;\n  for (int i = 0; i < s.length() - 1; i++)\n  {\n    score += abs(s[i + 1] - s[i]);\n  }\n  return score;\n}\n\nint main()\n{\n  string s;\n  cout << \"Enter string: \";\n  cin >> s;\n\n  int result = scoreOfString(s);\n  cout << \"Score: \" << result << endl;\n\n  // Uncomment for debug output:\n  // scoreOfStringDebug(s);\n\n  return 0;\n}"
    },
    {
      "name": "Second Largest",
      "filename": "SecondLargest.c++",
      "path": "practices/Arrays/Easy/SecondLargest.c++",
      "content": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n/**\n * üéØ FIND SECOND LARGEST ELEMENT - Easy to Understand Version\n *\n * üß† Main Idea: Keep track of two variables:\n * - largest: The biggest number we've seen so far\n * - sLargest: The second biggest number we've seen so far\n *\n * üè† Real Life Analogy: Finding second tallest person in a group\n * 1. Look at each person one by one\n * 2. If someone is taller than current tallest ‚Üí they become tallest,\n *    old tallest becomes second tallest\n * 3. If someone is shorter than tallest but taller than second tallest ‚Üí\n *    they become second tallest\n */\n\n// Sample Input\n// 6\n// 3 7 1 7 8 2\n\nint findSecondLargest(int n, vector<int> &arr)\n{\n  if (n < 2)\n    return -1;\n  int largest = INT_MIN;\n  int sLargest = INT_MIN;\n\n  for (int i = 0; i < n; i++)\n  {\n    if (largest < arr[i])\n    {\n      sLargest = largest;\n      largest = arr[i];\n    }\n    else if (largest > arr[i] && sLargest < arr[i])\n    {\n      sLargest = arr[i];\n    }\n  }\n  return sLargest == INT_MIN ? -1 : sLargest;\n}\n\nint main()\n{\n  int n;\n  cout << \"Enter number of elements: \";\n  cin >> n;\n\n  vector<int> arr(n);\n  cout << \"Enter \" << n << \" elements: \";\n  for (int i = 0; i < n; i++)\n  {\n    cin >> arr[i];\n  }\n\n  cout << \"\\nArray: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n\n  int result = findSecondLargest(n, arr);\n\n  if (result == -1)\n  {\n    cout << \"\\nNo second largest element found!\" << endl;\n  }\n  else\n  {\n    cout << \"\\nSecond largest element: \" << result << endl;\n  }\n\n  return 0;\n}"
    },
    {
      "name": "Sortedand Rotated",
      "filename": "SortedandRotated.c++",
      "path": "practices/Arrays/Easy/SortedandRotated.c++",
      "content": "#include <iostream>\nusing namespace std;\n\n/*\n * Function to check if array is sorted and rotated\n *\n * Logic Explanation:\n * - A sorted array has 0 \"breaks\" (places where arr[i] > arr[i+1])\n * - A rotated sorted array has exactly 1 \"break\"\n * - Example: [1,2,3,4,5] has 0 breaks (sorted)\n * - Example: [3,4,5,1,2] has 1 break at position 2 (5>1) (rotated sorted)\n * - Example: [2,1,3,4] has 2 breaks (not sorted/rotated)\n *\n * We use modulo (%) to handle circular comparison (last element with first)\n */\nbool check(int nums[], int n)\n{\n  int count = 0; // Count number of \"breaks\" or decreasing points\n\n  // Check each element with its next element (circularly)\n  for (int i = 0; i < n; i++)\n  {\n    // Compare current element with next element (circular using %)\n    // (i + 1) % n ensures last element is compared with first element\n    if (nums[i] > nums[(i + 1) % n])\n      count++; // Found a decreasing point\n  }\n\n  // Array is sorted and rotated if there's at most 1 break\n  // count <= 1 covers both cases:\n  // - count == 0: perfectly sorted array\n  // - count == 1: sorted but rotated array\n  return count <= 1;\n}\n\nint main()\n{\n  cout << \"Enter the size of array: \";\n  int n;\n  cin >> n;\n\n  cout << \"Enter \" << n << \" elements: \";\n  int arr[n];\n  for (int i = 0; i < n; i++)\n    cin >> arr[i];\n\n  // Check if array is sorted (with possible rotation)\n  if (check(arr, n))\n    cout << \"Array is sorted and rotated\" << endl;\n  else\n    cout << \"Array is not sorted and rotated\" << endl;\n\n  return 0;\n}\n\n/*\n * Example Test Cases:\n *\n * Input: [1, 2, 3, 4, 5] ‚Üí Output: \"Array is sorted and rotated\" (0 breaks)\n * Input: [3, 4, 5, 1, 2] ‚Üí Output: \"Array is sorted and rotated\" (1 break)\n * Input: [2, 1, 3, 4]    ‚Üí Output: \"Array is not sorted and rotated\" (2 breaks)\n * Input: [1, 3, 2]       ‚Üí Output: \"Array is not sorted and rotated\" (2 breaks)\n */"
    },
    {
      "name": "Union",
      "filename": "Union.c++",
      "path": "practices/Arrays/Easy/Union.c++",
      "content": "#include <iostream>\n#include <set>\n#include <map>\nusing namespace std;\n\n//* Using Set\n// TC : O((m + n) log(m + n))\n// Space Complexity : O(m + n)\nvector<int> setUnion(int arr1[], int arr2[], int n, int m)\n{\n  set<int> s;\n  vector<int> Union;\n  for (int i = 0; i < n; i++)\n  {\n    s.insert(arr1[i]);\n  }\n  for (int i = 0; i < m; i++)\n  {\n    s.insert(arr2[i]);\n  }\n\n  for (auto it : s)\n  {\n    Union.push_back(it);\n  }\n  return Union;\n}\n//* Using Map\n// TC : O((m + n) log(m + n))\n// Space Complexity : O(m + n)\n\nvector<int> mapUnion(int arr1[], int arr2[], int n, int m)\n{\n  map<int, int> mpp;\n  vector<int> Union;\n  for (int i = 0; i < n; i++)\n  {\n    mpp[arr1[i]]++;\n  }\n  for (int i = 0; i < m; i++)\n  {\n    mpp[arr2[i]]++;\n  }\n  for (auto it : mpp)\n  {\n    Union.push_back(it.first);\n  }\n  return Union;\n}\n\n// * using TowPointer\n\n// * Using the property that the arrays are sorted we can bring down the time complexity from\n\n// * O((m + n) log(m + n)) TO O(m + n).\n\nvector<int> usingTowPointer(int arr1[], int arr2[], int n, int m)\n{\n  vector<int> Union;\n  int j = 0, i = 0;\n\n  while (i < n && j < m)\n  {\n    if (arr1[i] <= arr2[j])\n    {\n      if (Union.size() == 0 || Union.back() != arr1[i])\n        Union.push_back(arr1[i]);\n      i++;\n    }\n    else\n    {\n      if (Union.size() == 0 || Union.back() != arr2[j])\n        Union.push_back(arr2[j]);\n      j++;\n    }\n  }\n  while (i < n)\n  {\n    if (Union.size() == 0 || Union.back() != arr1[i])\n      Union.push_back(arr1[i]);\n    i++;\n  }\n  while (j < m)\n  {\n    if (Union.size() == 0 || Union.back() != arr2[j])\n      Union.push_back(arr2[j]);\n    j++;\n  }\n\n  return Union;\n}\n\nint main()\n{\n  // Sample case:\n  // 5\n  // 1 2 3 4 5\n  // 5\n  // 3 4 5 6 7\n  // Expected Union: [1, 2, 3, 4, 5, 6, 7]\n\n  int n1, n2;\n\n  cout << \"Enter size of first array: \";\n  cin >> n1;\n  int arr1[n1];\n\n  cout << \"Enter elements of first array: \";\n  for (int i = 0; i < n1; i++)\n  {\n    cin >> arr1[i];\n  }\n\n  cout << \"Enter size of second array: \";\n  cin >> n2;\n  int arr2[n2];\n\n  cout << \"Enter elements of second array: \";\n  for (int i = 0; i < n2; i++)\n  {\n    cin >> arr2[i];\n  }\n\n  // vector<int> result = setUnion(arr1, arr2, n1, n2);\n  // vector<int> result = mapUnion(arr1, arr2, n1, n2);\n  vector<int> result = usingTowPointer(arr1, arr2, n1, n2);\n\n  cout << \"Union: \";\n  for (int x : result)\n  {\n    cout << x << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}"
    }
  ],
  "Arrays - Medium": [
    {
      "name": "buy_sell Stock",
      "filename": "buy_sellStock.c++",
      "path": "practices/Arrays/Medium/buy_sellStock.c++",
      "content": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n/*\nPROBLEM: Best Time to Buy and Sell Stock\n- You are given an array prices where prices[i] is the price of a given stock on the ith day.\n- You want to maximize your profit by choosing a single day to buy one stock\n  and choosing a different day in the future to sell that stock.\n- Return the maximum profit you can achieve from this transaction.\n- If you cannot achieve any profit, return 0.\n\nALGORITHM EXPLANATION:\nThe key insight is that we want to buy at the lowest price we've seen so far\nand sell at the current price to maximize profit.\n\n1. Keep track of minimum price seen so far (mini)\n2. For each day, calculate potential profit if we sell today (current_price - mini)\n3. Update maximum profit if current profit is better\n4. Update minimum price if current price is lower\n\nTime Complexity: O(n) - single pass through array\nSpace Complexity: O(1) - only using constant extra space\n*/\n\nclass Solution\n{\npublic:\n    int maxProfit(vector<int> &arr)\n    {\n        int profit = 0;    // Maximum profit we can achieve\n        int mini = arr[0]; // Minimum price seen so far (best day to buy)\n\n        for (int i = 1; i < arr.size(); i++)\n        {\n            // Calculate profit if we sell today\n            int val = arr[i] - mini;\n\n            // Update maximum profit\n            profit = max(profit, val);\n\n            // Update minimum price (better buying opportunity)\n            mini = min(mini, arr[i]);\n        }\n        return profit;\n    }\n};\n\n// Helper function to test the solution\nvoid testMaxProfit(vector<int> prices, string testName)\n{\n    Solution sol;\n    int result = sol.maxProfit(prices);\n\n    cout << \"\\n\"\n         << testName << \":\" << endl;\n    cout << \"Prices: [\";\n    for (int i = 0; i < prices.size(); i++)\n    {\n        cout << prices[i];\n        if (i < prices.size() - 1)\n            cout << \", \";\n    }\n    cout << \"]\" << endl;\n    cout << \"Maximum Profit: \" << result << endl;\n\n    // Find the actual buy and sell days for demonstration\n    int mini = prices[0], buyDay = 0, sellDay = 0, maxProfit = 0;\n    for (int i = 1; i < prices.size(); i++)\n    {\n        if (prices[i] - mini > maxProfit)\n        {\n            maxProfit = prices[i] - mini;\n            sellDay = i;\n            // Find the buy day\n            for (int j = 0; j < i; j++)\n            {\n                if (prices[j] == mini)\n                {\n                    buyDay = j;\n                    break;\n                }\n            }\n        }\n        if (prices[i] < mini)\n        {\n            mini = prices[i];\n        }\n    }\n\n    if (result > 0)\n    {\n        cout << \"Buy on day \" << buyDay << \" (price: \" << prices[buyDay]\n             << \"), Sell on day \" << sellDay << \" (price: \" << prices[sellDay] << \")\" << endl;\n    }\n    else\n    {\n        cout << \"No profitable transaction possible\" << endl;\n    }\n}\n\nint main()\n{\n    cout << \"=== Best Time to Buy and Sell Stock ===\" << endl;\n\n    // Test Case 1: Normal case with profit\n    testMaxProfit({7, 1, 5, 3, 6, 4}, \"Test Case 1\");\n\n    // Test Case 2: Decreasing prices (no profit)\n    testMaxProfit({7, 6, 4, 3, 1}, \"Test Case 2\");\n\n    // Test Case 3: Single element\n    testMaxProfit({5}, \"Test Case 3\");\n\n    // Test Case 4: Two elements\n    testMaxProfit({1, 5}, \"Test Case 4\");\n\n    // Test Case 5: All same prices\n    testMaxProfit({3, 3, 3, 3}, \"Test Case 5\");\n\n    // Test Case 6: Increasing prices\n    testMaxProfit({1, 2, 3, 4, 5}, \"Test Case 6\");\n\n    cout << \"\\n=== Step-by-step explanation for [7, 1, 5, 3, 6, 4] ===\" << endl;\n    vector<int> example = {7, 1, 5, 3, 6, 4};\n    int profit = 0, mini = example[0];\n\n    cout << \"Initial: profit = 0, mini = \" << mini << endl;\n\n    for (int i = 1; i < example.size(); i++)\n    {\n        int val = example[i] - mini;\n        cout << \"Day \" << i << \": price = \" << example[i]\n             << \", profit if sell today = \" << example[i] << \" - \" << mini << \" = \" << val;\n\n        profit = max(profit, val);\n        mini = min(mini, example[i]);\n\n        cout << \" ‚Üí profit = \" << profit << \", mini = \" << mini << endl;\n    }\n\n    return 0;\n}\n"
    },
    {
      "name": "majority",
      "filename": "majority.cpp",
      "path": "practices/Arrays/Medium/majority.cpp",
      "content": "#include <iostream>\n#include <map>\n#include <vector>\nusing namespace std;\n\nint BruteForce(int arr[], int n)\n{\n  for (int i = 0; i < n; i++)\n  {\n    int cnt = 0;\n    for (int j = 0; j < n; j++)\n    {\n      if (arr[i] == arr[j])\n      {\n        cnt++;\n      }\n    }\n    if (cnt > n / 2)\n      return arr[i];\n  }\n\n  return -1;\n}\n\n// * Using map\n// TC: O(n), SC: O(n)\nint usingMap(int arr[], int n)\n{\n  map<int, int> mpp;\n  for (int i = 0; i < n; i++)\n  {\n    mpp[arr[i]]++;\n  }\n\n  for (auto it : mpp)\n  {\n    if (it.second > n / 2)\n    {\n      return it.first;\n    }\n  }\n\n  return -1;\n}\n// * Optimal Approach (Moore's Voting Algorithm)\n// TC: O(n), SC: O(1)\n\nint mooreVotingAlgo(int arr[], int n)\n{\n  int el = -1;\n  int cnt = 0;\n\n  // Phase 1: Find candidate\n  for (int i = 0; i < n; i++)\n  {\n\n    if (arr[i] == el)\n    {\n      cnt++;\n    }\n    else if (cnt == 0)\n    {\n      el = arr[i];\n      cnt = 1;\n    }\n    else\n      cnt--;\n  }\n\n  // Phase 2: Verify candidate\n  cnt = 0;\n\n  for (int i = 0; i < n; i++)\n  {\n    if (arr[i] == el)\n      cnt++;\n  }\n\n  if (cnt > n / 2)\n    return el;\n\n  return -1;\n}\n\nvoid runTestCase(int testNum, int arr[], int n, string method = \"All\")\n{\n  cout << \"\\n--- Test Case \" << testNum << \" ---\" << endl;\n  cout << \"Input: [\";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i];\n    if (i < n - 1)\n      cout << \", \";\n  }\n  cout << \"] (size: \" << n << \")\" << endl;\n\n  if (method == \"All\" || method == \"Brute Force\")\n  {\n    int result1 = BruteForce(arr, n);\n    cout << \"Brute Force: \" << (result1 == -1 ? \"No majority\" : to_string(result1)) << endl;\n  }\n\n  if (method == \"All\" || method == \"HashMap\")\n  {\n    int result2 = usingMap(arr, n);\n    cout << \"HashMap: \" << (result2 == -1 ? \"No majority\" : to_string(result2)) << endl;\n  }\n\n  if (method == \"All\" || method == \"Moore's Voting\")\n  {\n    int result3 = mooreVotingAlgo(arr, n);\n    cout << \"Moore's Voting: \" << (result3 == -1 ? \"No majority\" : to_string(result3)) << endl;\n  }\n}\n\nint main()\n{\n  cout << \"=== MAJORITY ELEMENT TEST CASES ===\" << endl;\n\n  // Test Case 1: Clear majority\n  int arr1[] = {3, 2, 3};\n  runTestCase(1, arr1, 3);\n\n  // Test Case 2: Another clear majority\n  int arr2[] = {2, 2, 1, 1, 1, 2, 2};\n  runTestCase(2, arr2, 7);\n\n  // Test Case 3: All same elements\n  int arr3[] = {1, 1, 1, 1};\n  runTestCase(3, arr3, 4);\n\n  // Test Case 4: No majority element\n  int arr4[] = {1, 2, 3, 4};\n  runTestCase(4, arr4, 4);\n\n  // Test Case 5: Single element\n  int arr5[] = {5};\n  runTestCase(5, arr5, 1);\n\n  // Test Case 6: Even split (no majority)\n  int arr6[] = {1, 1, 2, 2};\n  runTestCase(6, arr6, 4);\n\n  // Test Case 7: Large majority\n  int arr7[] = {1, 1, 1, 1, 2, 3};\n  runTestCase(7, arr7, 6);\n\n  // Test Case 8: Edge case - exactly half (no majority)\n  int arr8[] = {1, 1, 2, 2, 3, 3};\n  runTestCase(8, arr8, 6);\n\n  // cout << \"\\n--- Interactive Input ---\" << endl;\n  // int n;\n  // cout << \"Enter array size: \";\n  // cin >> n;\n  // int *arr = new int[n];\n  // cout << \"Enter array elements: \";\n  // for (int i = 0; i < n; i++)\n  //   cin >> arr[i];\n\n  // runTestCase(9, arr, n);\n\n  // delete[] arr;\n  return 0;\n}"
    },
    {
      "name": "max Sub Array",
      "filename": "maxSubArray.c++",
      "path": "practices/Arrays/Medium/maxSubArray.c++",
      "content": "#include <iostream>\n#include <vector>\n#include <climits>\nusing namespace std;\n\n//* Brute Code\n\nvector<int> MaxSubArray(int arr[], int n)\n{\n\n  int max = INT_MIN;\n  int firstIdx = -1, secondIdx = -1;\n  for (int i = 0; i < n; i++)\n  {\n    int sum = 0;\n    for (int j = i; j < n; j++)\n    {\n      sum += arr[j];\n      if (sum > max)\n      {\n        max = sum;\n        firstIdx = i;\n        secondIdx = j;\n      }\n    }\n  }\n  return {firstIdx, secondIdx};\n}\n\nvector<int> KadaneAlo(int arr[], int n)\n{\n  int max = INT_MIN;\n  int firstIdx = -1, secondIdx = -1;\n  int sum = 0;\n  int temp = 0;\n  for (int i = 0; i < n; i++)\n  {\n    sum += arr[i];\n\n    if (sum > max)\n    {\n      max = sum;\n      firstIdx = temp;\n      secondIdx = i;\n    }\n\n    if (sum < 0)\n    {\n      sum = 0;\n      temp = i + 1;\n    }\n  }\n  return {firstIdx, secondIdx};\n}\n\nint main()\n{\n  // Test case 1\n  cout << \"Test Case 1:\" << endl;\n  int arr1[] = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n  int n1 = sizeof(arr1) / sizeof(arr1[0]);\n\n  cout << \"Array: \";\n  for (int i = 0; i < n1; i++)\n  {\n    cout << arr1[i] << \" \";\n  }\n  cout << endl;\n\n  vector<int> result1 = MaxSubArray(arr1, n1);\n  int start1 = result1[0];\n  int end1 = result1[1];\n\n  cout << \"Maximum subarray is from index \" << start1 << \" to \" << end1 << endl;\n  cout << \"Subarray elements: \";\n  for (int i = start1; i <= end1; i++)\n  {\n    cout << arr1[i] << \" \";\n  }\n  cout << endl;\n\n  int maxSum1 = 0;\n  for (int i = start1; i <= end1; i++)\n  {\n    maxSum1 += arr1[i];\n  }\n  cout << \"Maximum sum: \" << maxSum1 << endl\n       << endl;\n\n  // Test case 2 - All negative numbers\n  cout << \"Test Case 2 (All negative):\" << endl;\n  int arr2[] = {-5, -2, -8, -1, -4};\n  int n2 = sizeof(arr2) / sizeof(arr2[0]);\n\n  cout << \"Array: \";\n  for (int i = 0; i < n2; i++)\n  {\n    cout << arr2[i] << \" \";\n  }\n  cout << endl;\n\n  vector<int> result2 = MaxSubArray(arr2, n2);\n  int start2 = result2[0];\n  int end2 = result2[1];\n\n  cout << \"Maximum subarray is from index \" << start2 << \" to \" << end2 << endl;\n  cout << \"Subarray elements: \";\n  for (int i = start2; i <= end2; i++)\n  {\n    cout << arr2[i] << \" \";\n  }\n  cout << endl;\n\n  int maxSum2 = 0;\n  for (int i = start2; i <= end2; i++)\n  {\n    maxSum2 += arr2[i];\n  }\n  cout << \"Maximum sum: \" << maxSum2 << endl\n       << endl;\n\n  // Test case 3 - All positive numbers\n  cout << \"Test Case 3 (All positive):\" << endl;\n  int arr3[] = {1, 2, 3, 4, 5};\n  int n3 = sizeof(arr3) / sizeof(arr3[0]);\n\n  cout << \"Array: \";\n  for (int i = 0; i < n3; i++)\n  {\n    cout << arr3[i] << \" \";\n  }\n  cout << endl;\n\n  vector<int> result3 = MaxSubArray(arr3, n3);\n  int start3 = result3[0];\n  int end3 = result3[1];\n\n  cout << \"Maximum subarray is from index \" << start3 << \" to \" << end3 << endl;\n  cout << \"Subarray elements: \";\n  for (int i = start3; i <= end3; i++)\n  {\n    cout << arr3[i] << \" \";\n  }\n  cout << endl;\n\n  int maxSum3 = 0;\n  for (int i = start3; i <= end3; i++)\n  {\n    maxSum3 += arr3[i];\n  }\n  cout << \"Maximum sum: \" << maxSum3 << endl\n       << endl;\n\n  // Test case 4 - Single element\n  cout << \"Test Case 4 (Single element):\" << endl;\n  int arr4[] = {5};\n  int n4 = sizeof(arr4) / sizeof(arr4[0]);\n\n  cout << \"Array: \";\n  for (int i = 0; i < n4; i++)\n  {\n    cout << arr4[i] << \" \";\n  }\n  cout << endl;\n\n  vector<int> result4 = MaxSubArray(arr4, n4);\n  int start4 = result4[0];\n  int end4 = result4[1];\n\n  cout << \"Maximum subarray is from index \" << start4 << \" to \" << end4 << endl;\n  cout << \"Subarray elements: \";\n  for (int i = start4; i <= end4; i++)\n  {\n    cout << arr4[i] << \" \";\n  }\n  cout << endl;\n\n  int maxSum4 = 0;\n  for (int i = start4; i <= end4; i++)\n  {\n    maxSum4 += arr4[i];\n  }\n  cout << \"Maximum sum: \" << maxSum4 << endl;\n\n  // Testing Kadane's Algorithm\n  cout << \"\\n=== Testing Kadane's Algorithm ===\" << endl;\n\n  // Test case 1 with Kadane\n  cout << \"Test Case 1 (Kadane):\" << endl;\n  cout << \"Array: \";\n  for (int i = 0; i < n1; i++)\n  {\n    cout << arr1[i] << \" \";\n  }\n  cout << endl;\n\n  vector<int> kadaneResult1 = KadaneAlo(arr1, n1);\n  int kadaneStart1 = kadaneResult1[0];\n  int kadaneEnd1 = kadaneResult1[1];\n\n  cout << \"Maximum subarray is from index \" << kadaneStart1 << \" to \" << kadaneEnd1 << endl;\n  cout << \"Subarray elements: \";\n  for (int i = kadaneStart1; i <= kadaneEnd1; i++)\n  {\n    cout << arr1[i] << \" \";\n  }\n  cout << endl;\n\n  int kadaneMaxSum1 = 0;\n  for (int i = kadaneStart1; i <= kadaneEnd1; i++)\n  {\n    kadaneMaxSum1 += arr1[i];\n  }\n  cout << \"Maximum sum: \" << kadaneMaxSum1 << endl;\n\n  return 0;\n}"
    },
    {
      "name": "Rearrange Array",
      "filename": "RearrangeArray.c++",
      "path": "practices/Arrays/Medium/RearrangeArray.c++",
      "content": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// * Using Two Pointer\n\nvoid RearrageArray(int arr[], int n)\n{\n  vector<int> neg;\n  vector<int> ptv;\n  for (int i = 0; i < n; i++)\n  {\n    if (arr[i] < 0)\n    {\n      neg.push_back(arr[i]);\n    }\n    else\n    {\n      ptv.push_back(arr[i]);\n    }\n  }\n  for (int i = 0; i < n; i++)\n  {\n    if (i % 2 == 0)\n    {\n      arr[i] = ptv[i / 2];\n    }\n    else\n    {\n      arr[i] = neg[i / 2];\n    }\n  }\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  int arr[n];\n  for (int i = 0; i < n; i++)\n    cin >> arr[i];\n\n  cout << \"Original array: \";\n  for (int i = 0; i < n; i++)\n    cout << arr[i] << \" \";\n  cout << endl;\n\n  RearrageArray(arr, n);\n\n  cout << \"Rearranged array: \";\n  for (int i = 0; i < n; i++)\n    cout << arr[i] << \" \";\n  cout << endl;\n  return 0;\n}"
    },
    {
      "name": "Sort An Arrayof_0's_1's_ And_2's",
      "filename": "SortAnArrayof_0's_1's_And_2's.c++",
      "path": "practices/Arrays/Medium/SortAnArrayof_0's_1's_And_2's.c++",
      "content": "#include <iostream>\nusing namespace std;\n\nint BruteForce(int arr[], int n) // Fixed typo: BruteFroce -> BruteForce\n{\n  int maxNum = -1;\n  for (int i = 0; i < n; i++)\n  {\n    int cnt = 0;\n    for (int j = 0; j < n; j++) // Fixed: was i++ instead of j++\n    {\n      if (arr[i] == arr[j])\n      {\n        cnt++;\n      }\n    }\n    maxNum = max(maxNum, cnt);\n  }\n  return maxNum;\n}\n\nvoid runTestCase(int testNum, int arr[], int n)\n{\n  cout << \"\\n--- Test Case \" << testNum << \" ---\" << endl;\n  cout << \"Input: [\";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i];\n    if (i < n - 1)\n      cout << \", \";\n  }\n  cout << \"] (size: \" << n << \")\" << endl;\n\n  int result = BruteForce(arr, n);\n  cout << \"Maximum frequency: \" << result << endl;\n\n  if (result > n / 2)\n  {\n    cout << \"Has majority element (appears more than \" << n / 2 << \" times)\" << endl;\n  }\n  else\n  {\n    cout << \"No majority element\" << endl;\n  }\n}\n\nint main()\n{\n  cout << \"=== MAJORITY ELEMENT TEST CASES ===\" << endl;\n\n  // Test Case 1: Clear majority\n  int arr1[] = {3, 2, 3};\n  runTestCase(1, arr1, 3);\n\n  // Test Case 2: Another clear majority\n  int arr2[] = {2, 2, 1, 1, 1, 2, 2};\n  runTestCase(2, arr2, 7);\n\n  // Test Case 3: All same elements\n  int arr3[] = {1, 1, 1, 1};\n  runTestCase(3, arr3, 4);\n\n  // Test Case 4: No majority element\n  int arr4[] = {1, 2, 3, 4};\n  runTestCase(4, arr4, 4);\n\n  // Test Case 5: Single element\n  int arr5[] = {5};\n  runTestCase(5, arr5, 1);\n\n  // Test Case 6: Even split (no majority)\n  int arr6[] = {1, 1, 2, 2};\n  runTestCase(6, arr6, 4);\n\n  // Test Case 7: Large majority\n  int arr7[] = {1, 1, 1, 1, 2, 3};\n  runTestCase(7, arr7, 6);\n\n  // Test Case 8: Edge case - exactly half (no majority)\n  int arr8[] = {1, 1, 2, 2, 3, 3};\n  runTestCase(8, arr8, 6);\n\n  cout << \"\\n--- Interactive Input ---\" << endl;\n  int n;\n  cout << \"Enter array size: \";\n  cin >> n;\n  int *arr = new int[n];\n  cout << \"Enter array elements: \";\n  for (int i = 0; i < n; i++)\n    cin >> arr[i];\n\n  runTestCase(9, arr, n);\n\n  delete[] arr;\n  return 0;\n}"
    },
    {
      "name": "Tow Sum",
      "filename": "TowSum.c++",
      "path": "practices/Arrays/Medium/TowSum.c++",
      "content": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\n// * Brute Force Approach\n// TC: O(n^2), SC: O(1)\npair<int, int> BruteForce(int arr[], int n, int target)\n{\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = i + 1; j < n; j++) // Start j from i+1 to avoid same element\n    {\n      if (arr[i] + arr[j] == target)\n      {\n        return {i, j}; // Return immediately when found\n      }\n    }\n  }\n  return {-1, -1}; // Return -1, -1 if no pair found\n}\n\n// * Hash Map Approach (Optimal)\n// TC: O(n), SC: O(n)\npair<int, int> TwoSumHash(int arr[], int n, int target)\n{\n  map<int, int> mpp;\n  for (int i = 0; i < n; i++)\n  {\n    int rem = target - arr[i];\n    if (mpp.find(rem) != mpp.end())\n    {\n      return {mpp[rem], i};\n    }\n    mpp[arr[i]] = i;\n  }\n  return {-1, -1};\n}\n\nvoid runTestCase(int testNum, int arr[], int n, int target, string method = \"Brute Force\")\n{\n  cout << \"\\n--- Test Case \" << testNum << \" (\" << method << \") ---\" << endl;\n  cout << \"Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << \"\\nTarget: \" << target << endl;\n\n  pair<int, int> result;\n  if (method == \"Brute Force\")\n    result = BruteForce(arr, n, target);\n  else\n    result = TwoSumHash(arr, n, target);\n\n  if (result.first == -1)\n  {\n    cout << \"No pair found with sum \" << target << endl;\n  }\n  else\n  {\n    cout << \"Pair found at indices [\" << result.first << \", \" << result.second << \"]\" << endl;\n    cout << \"Elements: \" << arr[result.first] << \" + \" << arr[result.second]\n         << \" = \" << target << endl;\n  }\n}\n\nint main()\n{\n  cout << \"=== TWO SUM PROBLEM ===\" << endl;\n\n  // Test Case 1: Normal case\n  int arr1[] = {2, 7, 11, 15};\n  runTestCase(1, arr1, 4, 9, \"Brute Force\");\n  runTestCase(1, arr1, 4, 9, \"Hash Map\");\n\n  // Test Case 2: Multiple pairs possible\n  int arr2[] = {3, 2, 4};\n  runTestCase(2, arr2, 3, 6, \"Brute Force\");\n  runTestCase(2, arr2, 3, 6, \"Hash Map\");\n\n  // Test Case 3: Same number twice\n  int arr3[] = {3, 3};\n  runTestCase(3, arr3, 2, 6, \"Brute Force\");\n  runTestCase(3, arr3, 2, 6, \"Hash Map\");\n\n  // Test Case 4: No solution\n  int arr4[] = {1, 2, 3, 4};\n  runTestCase(4, arr4, 4, 10, \"Brute Force\");\n  runTestCase(4, arr4, 4, 10, \"Hash Map\");\n\n  // Test Case 5: Negative numbers\n  int arr5[] = {-1, -2, -3, -4, -5};\n  runTestCase(5, arr5, 5, -8, \"Brute Force\");\n  runTestCase(5, arr5, 5, -8, \"Hash Map\");\n\n  // cout << \"\\n--- Interactive Input ---\" << endl;\n  // int n, target;\n  // cout << \"Enter array size: \";\n  // cin >> n;\n\n  // int *arr = new int[n];\n  // cout << \"Enter array elements: \";\n  // for (int i = 0; i < n; i++)\n  //   cin >> arr[i];\n\n  // cout << \"Enter target sum: \";\n  // cin >> target;\n\n  // runTestCase(6, arr, n, target, \"Brute Force\");\n  // runTestCase(6, arr, n, target, \"Hash Map\");\n\n  // delete[] arr;\n  return 0;\n}"
    }
  ],
  "Sorting I": [
    {
      "name": "Bubble Sort",
      "filename": "BubbleSort.c++",
      "path": "practices/LearnImportantSortingTechniques/sorting-I/BubbleSort.c++",
      "content": "#include <iostream>\nusing namespace std;\n\n//*Sample Input\n// 5\n// 2 5 3 1 3\n\n// * Example Execution; // Push the maxValue at last by Adjusent swaping\n// Example Execution : For array [64, 34, 25, 12, 22]\n\n// Pass 1 : [ 34, 25, 12, 22, 64 ]\n\n//  Pass 2 : [ 25, 12, 22, 34, 64 ]\n\n// Pass 3 : [ 12, 22, 25, 34, 64 ]\n\n// Pass 4 : [ 12, 22, 25, 34, 64 ]\n\n// Time Complexity : O(n^2) for best case O(N)\n// Space Complexity : O(1)\nvoid bubbleSort(int arr[], int n)\n{\n  for (int i = 0; i < n - 1; i++)\n  {\n    bool didSwap = false;\n    for (int j = 0; j < n - i - 1; j++)\n    {\n      if (arr[j] > arr[j + 1])\n      {\n        swap(arr[j], arr[j + 1]);\n        didSwap = true;\n      }\n    }\n    if (!didSwap)\n    {\n      break;\n    }\n  }\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  int arr[n];\n  for (int i = 0; i < n; i++)\n    cin >> arr[i];\n\n  bubbleSort(arr, n);\n  cout << \"Sorted Array\\n\";\n  for (int i = 0; i < n; i++)\n    cout << arr[i] << \" \";\n  return 0;\n}"
    },
    {
      "name": "Insertion Sort",
      "filename": "InsertionSort.c++",
      "path": "practices/LearnImportantSortingTechniques/sorting-I/InsertionSort.c++",
      "content": "#include <iostream>\nusing namespace std;\n\n// * Sample Input\n// 6\n// 7 9 3 9 4 2\n\n// * Example Execution; // Take an element & place it at it's correct Position\n// Example Execution : For array [64, 34, 25, 12, 22]\n\n// Pass 1 : [ 34, 64, 25, 12, 22 ]\n// Pass 2 : [ 25, 34, 64, 12, 22 ]\n// Pass 3 : [ 12, 25, 34, 64, 22 ]\n// Pass 4 : [ 12, 22, 25, 34, 64 ]\n\n// Time Complexity : O(n^2)\n// Space Complexity : O(1)\n\nvoid InsertionSort(int arr[], int n)\n{\n  for (int i = 0; i < n; i++)\n  {\n    int j = i;\n    while (j > 0 && arr[j - 1] > arr[j])\n    {\n      swap(arr[j - 1], arr[j]);\n      j--;\n    }\n  }\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  int arr[n];\n  for (int i = 0; i < n; i++)\n    cin >> arr[i];\n\n  InsertionSort(arr, n);\n\n  cout << \"Sorted Array\\n\";\n  for (int i = 0; i < n; i++)\n    cout << arr[i] << \" \";\n  return 0;\n}"
    },
    {
      "name": "Selection Sort",
      "filename": "SelectionSort.c++",
      "path": "practices/LearnImportantSortingTechniques/sorting-I/SelectionSort.c++",
      "content": "#include <iostream>\nusing namespace std;\n\n// * Sample Input\n// 6\n// 7 9 3 9 4 2\n\n// * Example Execution; // Select Min and swap\n// Example Execution : For array [64, 34, 25, 12, 22]\n\n// Pass 1 : [ 12, 34, 25, 64, 22 ]\n\n// Pass 2 : [ 12, 22, 25, 64, 34 ]\n\n// Pass 3 : [ 12, 22, 25, 64, 34 ]\n\n// Pass 4 : [ 12, 22, 25, 34, 64 ]\n\n// Time Complexity : O(n^2) Same for all\n// Space Complexity : O(1)\nvoid selectionSort(int arr[], int n)\n{\n  for (int i = 0; i <= n - 2; i++)\n  { // * Last element will always be sorted\n    int min = i;\n    for (int j = i; j < n; j++)\n    {\n      if (arr[j] < arr[min])\n        min = j;\n    }\n    swap(arr[min], arr[i]);\n  }\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  int arr[n];\n  for (int i = 0; i < n; i++)\n  {\n    cin >> arr[i];\n  }\n\n  selectionSort(arr, n);\n\n  cout << \"Sorted Array\\n\";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  return 0;\n}"
    }
  ],
  "Sorting II": [
    {
      "name": "Merge Sort",
      "filename": "MergeSort.c++",
      "path": "practices/LearnImportantSortingTechniques/sorting-II/MergeSort.c++",
      "content": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// * MERGE SORT - Divide and Conquer Algorithm\n// * Time Complexity: O(n log n) - Best, Average, Worst case\n// * Space Complexity: O(n) - Due to temporary array\n\n// * Sample Input:\n// 6\n// 2 3 9 2 4 3\n// * Expected Output: 2 2 3 3 4 9\n\n/**\n * MERGE Function: Combines two sorted subarrays into one sorted array\n * @param arr: The main array\n * @param low: Starting index of first subarray\n * @param mid: Ending index of first subarray (mid+1 starts second subarray)\n * @param high: Ending index of second subarray\n */\nvoid merge(int arr[], int low, int mid, int high)\n{\n  // Step 1: Create temporary array to store merged result\n  vector<int> temp;\n\n  // Step 2: Initialize pointers for both subarrays\n  int left = low;      // Pointer for first subarray [low...mid]\n  int right = mid + 1; // Pointer for second subarray [mid+1...high]\n\n  // Step 3: Compare elements and merge in sorted order\n  while (left <= mid && right <= high)\n  {\n    if (arr[left] <= arr[right])\n    {\n      temp.push_back(arr[left]);\n      left++;\n    }\n    else\n    {\n      temp.push_back(arr[right]);\n      right++;\n    }\n  }\n\n  // Step 4: Add remaining elements from left subarray (if any)\n  while (left <= mid)\n  {\n    temp.push_back(arr[left]);\n    left++;\n  }\n\n  // Step 5: Add remaining elements from right subarray (if any)\n  while (right <= high)\n  {\n    temp.push_back(arr[right]);\n    right++;\n  }\n\n  // Step 6: Copy merged elements back to original array\n  for (int i = low; i <= high; i++)\n  {\n    arr[i] = temp[i - low]; // temp[0] goes to arr[low]\n  }\n}\n\n/**\n * MERGE SORT Function: Recursively divides array and sorts\n * @param arr: The array to be sorted\n * @param low: Starting index\n * @param high: Ending index\n */\nvoid mergeSort(int arr[], int low, int high)\n{\n  // Base case: If array has 1 or 0 elements, it's already sorted\n  if (low >= high)\n    return;\n\n  // Step 1: Find middle point to divide array into two halves\n  int mid = (low + high) / 2;\n\n  // Step 2: Recursively sort first half\n  mergeSort(arr, low, mid);\n\n  // Step 3: Recursively sort second half\n  mergeSort(arr, mid + 1, high);\n\n  // Step 4: Merge the two sorted halves\n  merge(arr, low, mid, high);\n}\n\n/**\n * MAIN Function: Driver code to test merge sort\n */\nint main()\n{\n  // Input: Read array size and elements\n  int n;\n  cout << \"Enter number of elements: \";\n  cin >> n;\n\n  int arr[100]; // Array to store elements (max 100)\n  cout << \"Enter \" << n << \" elements: \";\n  for (int i = 0; i < n; i++)\n  {\n    cin >> arr[i];\n  }\n\n  // Display original array\n  cout << \"\\nOriginal Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n\n  // Sort the array using merge sort\n  mergeSort(arr, 0, n - 1);\n\n  // Display sorted array\n  cout << \"Sorted Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}\n\n/*\n * HOW MERGE SORT WORKS:\n *\n * Example: [2, 3, 9, 2, 4, 3]\n *\n * Step 1: Divide\n *         [2, 3, 9, 2, 4, 3]\n *        /                  \\\n *   [2, 3, 9]           [2, 4, 3]\n *   /      \\            /      \\\n * [2, 3]   [9]      [2, 4]   [3]\n * /   \\              /   \\\n *[2]  [3]          [2]  [4]\n *\n * Step 2: Conquer (Merge back)\n * [2]  [3]  ‚Üí  [2, 3]\n * [2]  [4]  ‚Üí  [2, 4]\n * [2, 3] [9]  ‚Üí  [2, 3, 9]\n * [2, 4] [3]  ‚Üí  [2, 3, 4]\n * [2, 3, 9] [2, 3, 4]  ‚Üí  [2, 2, 3, 3, 4, 9]\n *\n * Final Result: [2, 2, 3, 3, 4, 9]\n */"
    },
    {
      "name": "Quick Sort",
      "filename": "QuickSort.c++",
      "path": "practices/LearnImportantSortingTechniques/sorting-II/QuickSort.c++",
      "content": "#include <iostream>\nusing namespace std;\n\n/**\n * üéØ QUICKSORT - The \"Divide and Conquer\" Sorting Algorithm\n *\n * üß† Main Idea: Pick a \"pivot\" element and arrange the array so that:\n * - All smaller elements go to the LEFT of pivot\n * - All larger elements go to the RIGHT of pivot\n * - Then sort left and right parts separately\n *\n * üè† Real Life Analogy: Organizing a classroom by height\n * 1. Pick one student as \"reference height\" (pivot)\n * 2. All shorter students stand on left, taller on right\n * 3. Organize left group and right group separately\n */\n\n// Sample Input\n// 8\n// 3 7 8 1 2 9 4 6\n\n/**\n * üîÑ STEP 1: PARTITION - Organize elements around pivot\n * This is like separating shorter and taller students\n *\n * @param arr: The array to partition\n * @param low: Start position\n * @param high: End position\n * @return: Final position where pivot ends up\n */\nint pivotSort(int arr[], int low, int high)\n{\n  int pivot = low; // üìç Choose first element as pivot\n  int i = low;     // üëà Left pointer (finds elements > pivot)\n  int j = high;    // üëâ Right pointer (finds elements < pivot)\n\n  cout << \"üéØ Pivot chosen: \" << arr[pivot] << \" (at position \" << pivot << \")\\n\";\n\n  while (i < j)\n  {\n    // üëà Move i right until we find element BIGGER than pivot\n    while (arr[i] <= arr[pivot] && i <= high)\n    {\n      i++;\n    }\n\n    // üëâ Move j left until we find element SMALLER than pivot\n    while (arr[j] > arr[pivot] && j >= low)\n    {\n      j--;\n    }\n\n    // üîÑ If pointers haven't crossed, swap the misplaced elements\n    if (i < j)\n    {\n      cout << \"  üîÑ Swapping \" << arr[i] << \" and \" << arr[j] << \"\\n\";\n      swap(arr[i], arr[j]);\n    }\n  }\n\n  // üéØ Put pivot in its correct final position\n  cout << \"  üéØ Moving pivot \" << arr[pivot] << \" to position \" << j << \"\\n\";\n  swap(arr[j], arr[pivot]);\n\n  cout << \"  üìä After partition: \";\n  for (int k = low; k <= high; k++)\n    cout << arr[k] << \" \";\n  cout << \"\\n\\n\";\n\n  return j; // Return pivot's final position\n}\n\n/**\n * üöÄ STEP 2: RECURSIVELY SORT - Sort left and right parts\n * Like organizing smaller groups separately\n *\n * @param arr: Array to sort\n * @param low: Start position\n * @param high: End position\n */\nvoid quickSort(int arr[], int low, int high)\n{\n  // üõë Base case: If section has 1 or 0 elements, it's already sorted\n  if (low < high)\n  {\n    cout << \"üìã Sorting section [\" << low << \" to \" << high << \"]: \";\n    for (int k = low; k <= high; k++)\n      cout << arr[k] << \" \";\n    cout << \"\\n\";\n\n    // üîÑ Partition: Organize around pivot\n    int pivotPosition = pivotSort(arr, low, high);\n\n    // üîÑ Recursively sort LEFT part (smaller elements)\n    cout << \"‚¨ÖÔ∏è  Sorting LEFT of pivot (position \" << pivotPosition << \")\\n\";\n    quickSort(arr, low, pivotPosition - 1);\n\n    // üîÑ Recursively sort RIGHT part (larger elements)\n    cout << \"‚û°Ô∏è  Sorting RIGHT of pivot (position \" << pivotPosition << \")\\n\";\n    quickSort(arr, pivotPosition + 1, high);\n  }\n}\n\nint main()\n{\n  int n;\n  cout << \"Enter number of elements: \";\n  cin >> n;\n\n  int arr[100];\n  cout << \"Enter \" << n << \" elements: \";\n  for (int i = 0; i < n; i++)\n  {\n    cin >> arr[i];\n  }\n\n  cout << \"\\nüî¢ Original Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << \"\\n\\nüöÄ Starting QuickSort...\\n\\n\";\n\n  quickSort(arr, 0, n - 1); // Sort from index 0 to n-1\n\n  cout << \"‚úÖ Final Sorted Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}\n\n/*\nüé≠ Visual Example : For input : [ 3, 7, 8, 1, 2, 9, 4, 6 ]\n\nüéØ Step 1 : Choose Pivot(3)\n\n    Array : [ 3, 7, 8, 1, 2, 9, 4, 6 ] Pivot : 3(first element)\n    Goal : Put all numbers < 3 on left,\n    all numbers > 3 on right\n\nüëâ Step 2 : Use Two Pointers\n\n        [3, 7, 8, 1, 2, 9, 4, 6]\n        P  i                 j\n\ni moves right looking for number > 3\nj moves left looking for number < 3\n\ni finds 7 (> 3), j finds 6 (> 3), j continues...\nj finds 4 (> 3), j continues...\nj finds 2 (< 3) ‚úì\n\nSwap 7 and 2: [3, 2, 8, 1, 7, 9, 4, 6]\n\nüîÑ Step 3: Continue Until Pointers Meet\n\nAfter several swaps: [3, 2, 1, 8, 7, 9, 4, 6]\n                      P     i        j\n\nWhen i and j cross, swap pivot with j:\n[1, 2, 3, 8, 7, 9, 4, 6]\n       ‚Üë\n   Pivot in correct position!\n\nüîÑ Step 4: Recursively Sort Left and Right\n\nLeft part:  [1, 2]     ‚Üí Already sorted!\nRight part: [8, 7, 9, 4, 6] ‚Üí Apply QuickSort again\n\nFinal result: [1, 2, 3, 4, 6, 7, 8, 9]\n*/\n"
    },
    {
      "name": "Recursive Bubble Sort",
      "filename": "RecursiveBubbleSort.c++",
      "path": "practices/LearnImportantSortingTechniques/sorting-II/RecursiveBubbleSort.c++",
      "content": "#include <iostream>\nusing namespace std;\n\n/**\n * RECURSIVE BUBBLE SORT - Easy to Understand Version\n *\n * How Bubble Sort Works:\n * 1. Compare adjacent elements and swap if they're in wrong order\n * 2. After each complete pass, the largest element \"bubbles up\" to the end\n * 3. Repeat for remaining elements (excluding the already sorted ones)\n */\n\n/**\n * @param arr: The array to sort\n * @param n: Number of elements left to sort (reduces with each pass)\n * @param i: Current position we're comparing (starts from 0 each pass)\n */\nvoid rBubbleSort(int arr[], int n, int i)\n{\n  // BASE CASE: If no elements left to sort, we're done!\n  if (n == 0)\n  {\n    return;\n  }\n\n  // If we haven't finished current pass\n  if (i < n)\n  {\n    // Compare adjacent elements and swap if needed\n    if (arr[i] > arr[i + 1])\n    {\n      swap(arr[i], arr[i + 1]);\n      cout << \"Swapped \" << arr[i + 1] << \" and \" << arr[i] << endl;\n    }\n\n    // Move to next pair in current pass\n    rBubbleSort(arr, n, i + 1);\n  }\n  else\n  {\n    // Current pass complete! Start new pass with one less element\n    cout << \"Pass completed. Array now: \";\n    for (int k = 0; k <= n; k++)\n      cout << arr[k] << \" \";\n    cout << endl;\n\n    rBubbleSort(arr, n - 1, 0);\n  }\n}\n\nint main()\n{\n  int n;\n  cout << \"Enter number of elements: \";\n  cin >> n;\n\n  int arr[100];\n  cout << \"Enter \" << n << \" elements: \";\n  for (int i = 0; i < n; i++)\n  {\n    cin >> arr[i];\n  }\n\n  cout << \"\\nOriginal Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << \"\\n\\nSorting Process:\\n\";\n\n  // Start sorting with (n-1) comparisons needed in first pass\n  rBubbleSort(arr, n - 1, 0);\n\n  cout << \"\\nFinal Sorted Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}"
    },
    {
      "name": "Recursive Insertion Sort",
      "filename": "RecursiveInsertionSort.c++",
      "path": "practices/LearnImportantSortingTechniques/sorting-II/RecursiveInsertionSort.c++",
      "content": "#include <iostream>\nusing namespace std;\n\n/**\n * RECURSIVE INSERTION SORT - Complete Implementation\n *\n * How Insertion Sort Works:\n * 1. Start from the second element (index 1)\n * 2. Compare it with previous elements and insert it in correct position\n * 3. Repeat for all remaining elements\n * 4. Each element gets \"inserted\" into the already sorted portion\n */\n\n/**\n * Helper function to insert element at correct position\n * @param arr: The array\n * @param i: Current element's original position\n */\nvoid insertElement(int arr[], int i)\n{\n  // Base case: if we're at the beginning or element is in correct position\n  if (i <= 0 || arr[i - 1] <= arr[i])\n    return;\n\n  // Swap with previous element and continue\n  swap(arr[i - 1], arr[i]);\n  insertElement(arr, i - 1);\n}\n\n/**\n * Main recursive insertion sort function\n * @param arr: The array to sort\n * @param n: Number of elements to sort\n * @param i: Current element we're inserting (starts from 1)\n */\nvoid rInsertionSort(int arr[], int n, int i)\n{\n  // Base case: if we've processed all elements\n  if (i >= n)\n    return;\n\n  // Insert current element in its correct position\n  insertElement(arr, i);\n\n  // Move to next element\n  rInsertionSort(arr, n, i + 1);\n}\n\nint main()\n{\n  int n;\n  cout << \"Enter number of elements: \";\n  cin >> n;\n\n  int arr[100];\n  cout << \"Enter \" << n << \" elements: \";\n  for (int i = 0; i < n; i++)\n  {\n    cin >> arr[i];\n  }\n\n  cout << \"\\nOriginal Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n\n  rInsertionSort(arr, n, 1); // Start from index 1\n\n  cout << \"\\nSorted Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}"
    },
    {
      "name": "Recursive Section Sort",
      "filename": "RecursiveSectionSort.c++",
      "path": "practices/LearnImportantSortingTechniques/sorting-II/RecursiveSectionSort.c++",
      "content": "#include <iostream>\nusing namespace std;\n\n// * RECURSIVE SELECTION SORT - Easy to Understand Version\n// * Sample Input: 5\n//                64 34 25 12 22\n// * Expected Output: 12 22 25 34 64\n\n/**\n * üîç STEP 1: Find the smallest number in the remaining array\n * Think of this like \"scanning\" the array to find the minimum\n *\n * @param arr: The array we're looking in\n * @param n: Total size of array\n * @param i: Starting position to look from\n * @return: Position (index) where smallest number is found\n */\nint minView(int arr[], int n, int i)\n{\n  int min = i; // Assume first element is smallest\n\n  // Look at all remaining elements\n  for (int j = i + 1; j < n; j++)\n  {\n    // If we find something smaller, remember its position\n    if (arr[j] < arr[min])\n      min = j;\n  }\n\n  return min; // Return position of smallest element\n}\n\n/**\n * üîÑ STEP 2: Put smallest number in correct position and repeat\n * This is like organizing books by height - always put shortest one first\n *\n * @param arr: Array to sort\n * @param n: Size of array\n * @param i: Current position we're filling (starts from 0)\n */\nvoid rSelectionSort(int arr[], int n, int i)\n{\n  // üõë STOP: If we've filled all positions except last one\n  if (i >= n - 1)\n    return;\n\n  // üîç Find where the smallest remaining number is\n  int minPosition = minView(arr, n, i);\n\n  // üîÑ Swap: Put smallest number in current position\n  swap(arr[i], arr[minPosition]);\n\n  cout << \"Step \" << i + 1 << \": Put \" << arr[i]\n       << \" in position \" << i << \" ‚Üí \";\n  for (int k = 0; k < n; k++)\n    cout << arr[k] << \" \";\n  cout << endl;\n\n  // üöÄ Recursive call: Fill next position\n  rSelectionSort(arr, n, i + 1);\n}\n\nint main()\n{\n  int n;\n  cout << \"Enter number of elements: \";\n  cin >> n;\n\n  int arr[100];\n  cout << \"Enter \" << n << \" elements: \";\n  for (int i = 0; i < n; i++)\n  {\n    cin >> arr[i];\n  }\n\n  cout << \"\\nüî¢ Original Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << \"\\n\\nüìã Sorting Process:\\n\";\n\n  rSelectionSort(arr, n, 0); // Start from position 0\n\n  cout << \"\\n‚úÖ Final Sorted Array: \";\n  for (int i = 0; i < n; i++)\n  {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n\n  return 0;\n}\n\n// üéØ Goal : Sort from smallest to largest\n\n// üìç Position 0 : Find smallest in[64, 34, 25, 12, 22]\n//    ‚Üí Found 12 at position 3\n//    ‚Üí Swap : [ 12, 34, 25, 64, 22 ]\n\n// üìç Position 1 : Find smallest in[34, 25, 64, 22]\n//    ‚Üí Found 22 at position 4\n//    ‚Üí Swap : [ 12, 22, 25, 64, 34 ]\n\n// üìç Position 2 : Find smallest in[25, 64, 34]\n//    ‚Üí Found 25 at position 2\n//    ‚Üí Swap : [ 12, 22, 25, 64, 34 ]\n\n// üìç Position 3 : Find smallest in[64, 34]\n//    ‚Üí Found 34 at position 4\n//    ‚Üí Swap : [ 12, 22, 25, 34, 64 ]\n\n// ‚úÖ Done !Array is sorted : [ 12, 22, 25, 34, 64 ]"
    }
  ],
  "Learning Basics": [
    {
      "name": "Armstrong Numbers",
      "filename": "ArmstrongNumbers.c++",
      "path": "practices/LearningBasic/ArmstrongNumbers.c++",
      "content": "#include <iostream>\nusing namespace std;\nbool isArmstrongNumber(int num)\n{\n  int temp = num;\n  int sum = 0;\n  int digitCount = to_string(num).length();\n  while (temp)\n  {\n    sum += pow(temp % 10, digitCount);\n    temp /= 10;\n  }\n  return sum == num;\n}\nint main()\n{\n  int num;\n  cin >> num;\n  if (isArmstrongNumber(num))\n  {\n    cout << num << \" is Armstrong Number\";\n  }\n  else\n  {\n    cout << num << \" not an Armstrong Number!\";\n  }\n  return 0;\n}"
    },
    {
      "name": "Basic Hashing",
      "filename": "BasicHashing.c++",
      "path": "practices/LearningBasic/BasicHashing.c++",
      "content": "#include <iostream>\nusing namespace std;\n//* Sample Input\n// 5\n// 1 2 1 3 4\n// 5\n// 1 2 3 4 5\n\nint main()\n{\n  int n;\n  cin >> n;\n  int arr[n];\n  for (int i = 0; i < n; i++)\n  {\n    cin >> arr[i];\n  }\n  // * preStorting\n  int hash[100] = {0};\n  for (int i = 0; i < n; i++)\n  {\n    hash[arr[i]]++;\n  }\n\n  int m;\n  cin >> m;\n  int arr1[n];\n  for (int i = 0; i < n; i++)\n  {\n\n    cin >> arr1[i];\n  }\n\n  for (int i = 0; i < n; i++)\n  {\n    //* Fetching\n    cout << hash[arr1[i]] << \" \";\n  }\n\n  return 0;\n}\n"
    },
    {
      "name": "Basic Recursion",
      "filename": "BasicRecursion.c++",
      "path": "practices/LearningBasic/BasicRecursion.c++",
      "content": "#include <iostream>\nusing namespace std;\n\n// * recursion :- when the function call's itself again and again\n// * Until a specified condition is meet's\n\n// * Print Sum of 1 to N;\n// int summ(int n) // * functional way\n// {\n//   // Base case: stop recursion when n reaches 0 or 1\n//   if (n <= 1)\n//     return 1;\n//   return n + summ(n - 1);\n// }\n\n// int main()\n// {\n//   int n;\n//   cin >> n;\n//   cout << summ(n) << endl;\n\n//   return 0;\n// }\n\n// !----------------------------------------------------------------\n\n// void summ(int n, int sum) // * parameteres way\n// {\n//   // Base case: stop recursion when n reaches 0 or 1\n//   if (n < 1)\n//   {\n//     cout << sum;\n//     return;\n//   }\n//   summ(n - 1, sum + n);\n// }\n\n// int main()\n// {\n//   int n;\n//   cin >> n;\n//   summ(n, 0);\n\n//   return 0;\n// }\n\n// !----------------------------------------------------------------\n\nint fact(int n)\n{\n  if (n == 1)\n    return 1;\n  return n * fact(n - 1);\n}\nint main()\n{\n  int n;\n  cin >> n;\n  cout << fact(n);\n  return 0;\n}"
    },
    {
      "name": "Char Hashing",
      "filename": "CharHashing.c++",
      "path": "practices/LearningBasic/CharHashing.c++",
      "content": "#include <iostream>\nusing namespace std;\n// ! Only for samll Alphabet // Capital Alphabet\n\n// * Sample Output\n// abcideadc\n// 5\n// a c d b f\n// int main()\n// {\n//   string s;\n//   cin >> s;\n//   int q;\n//   cin >> q; // * No of Queries\n//   //* PreComputing\n//   int hash[26] = {0};\n//   for (int i = 0; i < s.length(); i++)\n//   {\n//     hash[s[i] - 'a']++;\n//   }\n//   while (q--)\n//   {\n//     char c;\n//     cin >> c;\n//     // * fetch\n//     cout << hash[c - 'a'] << \" \";\n//   }\n//   return 0;\n// }\n\n// * -----------------------------------------------------------------------\n// ! Include all the element in char\n\n//* Sample OutPut\n// Ronakkumar\n// 5\n// k a m u R\n\nint main()\n{\n  string s;\n  cin >> s;\n  int q;\n  cin >> q; // * No of Queries\n  //* PreComputing\n  int hash[256] = {0};\n  for (int i = 0; i < s.length(); i++)\n  {\n    hash[s[i]]++; // remove the - 'a'\n    //* Because now the char 256 started from 0 to 256 char So where is no need of - 'a'\n  }\n  while (q--)\n  {\n    char c;\n    cin >> c;\n    // * fetch\n    cout << hash[c] << \" \";\n  }\n  return 0;\n}"
    },
    {
      "name": "Checkfor Prime",
      "filename": "CheckforPrime.c++",
      "path": "practices/LearningBasic/CheckforPrime.c++",
      "content": "#include <iostream>\nusing namespace std;\n\nbool isPrime(int num) // O(‚àön)\n{\n  if (num <= 1)\n    return false; // O(1)\n  if (num == 2)\n    return true; // O(1)\n  if (num % 2 == 0)\n    return false;                       // O(1)\n  for (int i = 3; i * i <= num; i += 2) // O(‚àön)\n  {\n    if (num % i == 0)\n    {\n      return false;\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int num;\n  cin >> num;\n  if (isPrime(num))\n  {\n    cout << num << \" is a Prime Number\";\n  }\n  else\n  {\n    cout << num << \" is not a Prime Number\";\n  }\n  return 0;\n}"
    },
    {
      "name": "G C D Or H C F",
      "filename": "GCDOrHCF.c++",
      "path": "practices/LearningBasic/GCDOrHCF.c++",
      "content": "#include <iostream>\n// #include <math.h>\nusing namespace std;\n// * brute Froce\n// int GreaterDivser(int n1, int n2)\n// {\n//   int value;\n//   for (int i = min(n1, n2); i >= 1; i++)\n//   {\n//     if (n1 % i == 0 && n2 % i == 0)\n//     {\n//       value = i;\n//       break;\n//     }\n//   }\n//   return value;\n// }\n// * better\nint GreaterDivser(int a, int b)\n{\n  int value;\n  while (a > 0 && b > 0)\n  {\n    if (a > b)\n      a %= b;\n    else\n    {\n      b %= a;\n    }\n  }\n  if (a == 0)\n    value = b;\n  else\n    value = a;\n  return value;\n}\n\nint main()\n{\n  int n1, n2;\n  cin >> n1 >> n2;\n  int gcd = GreaterDivser(n1, n2);\n  cout << gcd;\n  return 0;\n}"
    },
    {
      "name": "Hashing With S T L",
      "filename": "HashingWithSTL.c++",
      "path": "practices/LearningBasic/HashingWithSTL.c++",
      "content": "#include <iostream>\n#include <map>\nusing namespace std;\n\n//* Sample OutPut\n// 5\n// 2 3  100092 12 100092\n// 5\n// 2 4 100092 32321 12 3\n\nint main()\n{\n  int n;\n  cin >> n;\n  int arr[n];\n  map<int, int> mpp;\n\n  for (int i = 0; i < n; i++)\n  {\n    cin >> arr[i];\n    //* PreComputing\n    mpp[arr[i]]++;\n  }\n\n  // for (auto it : mpp)\n  // {\n  //   cout << it.first << \" -> \" << it.second << \"\\n\";\n  // }\n\n  int q; // no of queries\n  cin >> q;\n  while (q--)\n  {\n    int num;\n    cin >> num;\n    cout << mpp[num] << \" \";\n  }\n  return 0;\n}"
    },
    {
      "name": "Printall Divisors",
      "filename": "PrintallDivisors.cpp",
      "path": "practices/LearningBasic/PrintallDivisors.cpp",
      "content": "#include <iostream>\nusing namespace std;\nvector<int> printAllDivisors(int num)\n{\n  vector<int> value;\n  for (int i = 1; i <= sqrt(num); ++i)\n  {\n    //* Check if i divides n\n    //* without leaving a remainder\n    if (num % i == 0)\n    {\n      value.push_back(i);\n      //* Add the counterpart divisor\n      //* if it's different from i\n      //! Take reference from image folder\n      if (i != num / i)\n      {\n        value.push_back(num / i);\n      }\n    }\n  }\n  sort(value.begin(), value.end());\n  return value;\n}\nint main()\n{\n  int num;\n  cin >> num;\n  vector<int> value = printAllDivisors(num);\n\n  cout << '[';\n  for (int i : value)\n  {\n    cout << i;\n    if (i != num)\n      cout << \", \";\n  }\n  cout << ']';\n\n  return 0;\n}"
    },
    {
      "name": "Reverse An Array",
      "filename": "ReverseAnArray.c++",
      "path": "practices/LearningBasic/ReverseAnArray.c++",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid reverse(int arr[], int n, int i)\n{\n  // Base case: stop when we reach or pass the middle\n  if (i >= n / 2)\n    return;\n\n  // Swap elements from both ends\n  swap(arr[i], arr[n - i - 1]);\n\n  // Recursive call with next index\n  reverse(arr, n, i + 1);\n}\n\nint main()\n{\n  int n;\n  cout << \"Enter number of elements: \";\n  cin >> n;\n\n  int arr[100];\n  cout << \"Enter \" << n << \" elements: \";\n  for (int i = 0; i < n; i++)\n    cin >> arr[i];\n\n  cout << \"Original array: \";\n  for (int i = 0; i < n; i++)\n    cout << arr[i] << \" \";\n  cout << endl;\n\n  reverse(arr, n, 0);\n\n  cout << \"Reversed array: \";\n  for (int i = 0; i < n; i++)\n    cout << arr[i] << \" \";\n  cout << endl;\n\n  return 0;\n}"
    }
  ],
  "Patterns": [
    {
      "name": "pattern_1",
      "filename": "pattern_1.cpp",
      "path": "practices/Patterns/pattern_1.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P1.png\n// * * * *\n// * * * *\n// * * * *\n// * * * *\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n; j++)\n      cout << \"* \";\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_2",
      "filename": "pattern_2.cpp",
      "path": "practices/Patterns/pattern_2.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P2.png\n\n// *\n// * *\n// * * *\n// * * * *\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < i + 1; j++)\n    {\n      cout << \"* \";\n    }\n    cout << '\\n';\n  }\n\n  return 0;\n}"
    },
    {
      "name": "pattern_3",
      "filename": "pattern_3.cpp",
      "path": "practices/Patterns/pattern_3.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P3.png\n\n// *\n// * *\n// * * *\n// * * * *\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n  {\n    for (int j = 1; j <= i; j++)\n    {\n      cout << j << \" \";\n    }\n    cout << '\\n';\n  }\n\n  return 0;\n}"
    },
    {
      "name": "pattern_4",
      "filename": "pattern_4.cpp",
      "path": "practices/Patterns/pattern_4.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P4.png\n\n// *\n// * *\n// * * *\n// * * * *\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n  {\n    for (int j = 1; j <= i; j++)\n    {\n      cout << i << \" \";\n    }\n    cout << '\\n';\n  }\n\n  return 0;\n}"
    },
    {
      "name": "pattern_5",
      "filename": "pattern_5.cpp",
      "path": "practices/Patterns/pattern_5.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P5.png\n\n// *\n// * *\n// * * *\n// * * * *\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n  {\n    for (int j = n; j >= i; j--)\n    {\n      cout << \"* \";\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_6",
      "filename": "pattern_6.cpp",
      "path": "practices/Patterns/pattern_6.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P6.png\n\n// *\n// * *\n// * * *\n// * * * *\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n  {\n    for (int j = 1; j <= n - i + 1; j++)\n    {\n      cout << j << \" \";\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_7",
      "filename": "pattern_7.cpp",
      "path": "practices/Patterns/pattern_7.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P7.png\n\n//      *\n//    * * *\n//  * * * * *\n//* * * * * * *\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n  {\n    for (int j = 1; j <= n - i; j++)\n    {\n      cout << \"  \";\n    }\n    for (int k = 1; k <= 2 * i - 1; k++)\n    {\n      cout << '*' << \" \";\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_8",
      "filename": "pattern_8.cpp",
      "path": "practices/Patterns/pattern_8.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P8.png\n\n//* * * * * * *\n//  * * * * *\n//    * * *\n//      *\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n  {\n    for (int j = 1; j <= i; j++)\n    {\n      cout << \"  \";\n    }\n    for (int k = 1; k <= 2 * (n - i) + 1; k++)\n    {\n      cout << '*' << \" \";\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_9",
      "filename": "pattern_9.cpp",
      "path": "practices/Patterns/pattern_9.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P9.png\n\n//      *\n//    * * *\n//  * * * * *\n//* * * * * * *\n//* * * * * * *\n//  * * * * *\n//    * * *\n//      *\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 1; i <= 2 * n; i++)\n  {\n    int space = i <= n ? n - i : i - n - 1;\n    int star = i <= n ? 2 * i - 1 : 2 * (2 * n + 1 - i) - 1;\n    for (int j = 1; j <= space; j++)\n    {\n      cout << \"  \";\n    }\n\n    for (int k = 1; k <= star; k++)\n    {\n      cout << '*' << \" \";\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_10",
      "filename": "pattern_10.cpp",
      "path": "practices/Patterns/pattern_10.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P10.png\n\n//*\n//* *\n//* * *\n//* * * *\n//* * *\n//* *\n//*\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 0; i < 2 * n; i++)\n  {\n    int star = i <= n ? i : 2 * n - i;\n    for (int j = 1; j < star; j++)\n    {\n      cout << \"* \";\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_11",
      "filename": "pattern_11.cpp",
      "path": "practices/Patterns/pattern_11.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P11.png\n\n// 0\n// 1 0\n// 0 1 0\n// 1 0 1 0\n// 0 1 0 1 0\n// 1 0 1 0 1 0\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j <= i; j++)\n    {\n      cout << ((i + j) % 2) << \" \";\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_12",
      "filename": "pattern_12.cpp",
      "path": "practices/Patterns/pattern_12.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P12.png\n\n// 1                 1\n// 1 2             2 1\n// 1 2 3         3 2 1\n// 1 2 3 4     4 3 2 1\n// 1 2 3 4 5 5 4 3 2 1\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n  {\n\n    for (int j = 1; j <= i; j++)\n    {\n      cout << j << ' ';\n    }\n    int space = 2 * n - 2 * i;\n    for (int j = 0; j < space; j++)\n    {\n      cout << \"  \";\n    }\n    for (int j = i; j > 0; j--)\n    {\n      cout << j << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_13",
      "filename": "pattern_13.cpp",
      "path": "practices/Patterns/pattern_13.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P13.png\n\nint main()\n{\n  int n;\n  cin >> n;\n  int count = 1;\n  for (int i = 1; i <= n; i++)\n  {\n    for (int j = 1; j <= i; j++)\n    {\n      cout << count++ << ' ';\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_14",
      "filename": "pattern_14.cpp",
      "path": "practices/Patterns/pattern_14.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P14.png\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j <= i; j++)\n    {\n      cout << char('A' + j) << ' ';\n    }\n    cout << '\\n';\n  }\n}"
    },
    {
      "name": "pattern_15",
      "filename": "pattern_15.cpp",
      "path": "practices/Patterns/pattern_15.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P15.png\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j < n - i; j++)\n    {\n      cout << char('A' + j);\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_16",
      "filename": "pattern_16.cpp",
      "path": "practices/Patterns/pattern_16.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P16.png\n\n// A\n// B B\n// C C C\n// D D D D\n// E E E E E\n\nint main()\n{\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n; i++)\n  {\n    for (int j = 0; j <= i; j++)\n    {\n      cout << char('A' + i) << ' ';\n    }\n    cout << '\\n';\n  }\n\n  return 0;\n}"
    },
    {
      "name": "pattern_17",
      "filename": "pattern_17.cpp",
      "path": "practices/Patterns/pattern_17.cpp",
      "content": "#include <iostream>\nusing namespace std;\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P17.png\n//         A\n//       A B A\n//     A B C B A\n//   A B C D C B A\n// A B C D E D C B A\n\nint main()\n{\n  int n;\n  cin >> n;\n\n  for (int i = 0; i < n; i++)\n  {\n    int space = n - i;\n    for (int j = 0; j < space; j++)\n    {\n      cout << \"  \";\n    }\n    for (int j = 0; j < i; j++)\n    {\n      cout << char('A' + j) << ' ';\n    }\n    for (int j = i; j >= 0; j--)\n    {\n      cout << char('A' + j) << \" \";\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_18",
      "filename": "pattern_18.cpp",
      "path": "practices/Patterns/pattern_18.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P18.png\n\n// F\n// E F\n// D E F\n// C D E F\n// B C D E F\n// A B C D E F\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n  {\n    for (int j = 1; j <= i; j++)\n    {\n      cout << char('A' + n - i + j - 1) << ' ';\n    }\n    cout << '\\n';\n  }\n\n  return 0;\n}"
    },
    {
      "name": "pattern_19",
      "filename": "pattern_19.cpp",
      "path": "practices/Patterns/pattern_19.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P19.png\n// * * * * * * * * * *\n// * * * *     * * * *\n// * * *         * * *\n// * *             * *\n// *                 *\n// *                 *\n// * *             * *\n// * * *         * * *\n// * * * *     * * * *\n// * * * * * * * * * *\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 0; i < 2 * n; i++)\n  {\n    int star = i < n ? n - i : i - n + 1;\n    for (int j = 0; j < star; j++)\n    {\n      cout << \"* \";\n    }\n    int space = i < n ? 2 * i : 2 * (2 * n - i - 1);\n    for (int j = 0; j < space; j++)\n    {\n      cout << \"  \";\n    }\n    for (int j = 0; j < star; j++)\n    {\n      cout << \"* \";\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_20",
      "filename": "pattern_20.cpp",
      "path": "practices/Patterns/pattern_20.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P20.png\n// *                 *\n// * *             * *\n// * * *         * * *\n// * * * *     * * * *\n// * * * * * * * * * *\n// * * * *     * * * *\n// * * *         * * *\n// * *             * *\n// *                 *\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 0; i < 2 * n; i++)\n  {\n    int star = i < n ? i : (2 * n - i);\n    for (int j = 0; j < star; j++)\n    {\n      cout << \"* \";\n    }\n    int space = i < n ? 2 * (n - i) : 2 * (i - n);\n    for (int j = 0; j < space; j++)\n    {\n      cout << \"  \";\n    }\n    for (int j = 0; j < star; j++)\n    {\n      cout << \"* \";\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_21",
      "filename": "pattern_21.cpp",
      "path": "practices/Patterns/pattern_21.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\n// ? pattern image url :- https://static.takeuforward.org/wp/uploads/2022/08/P21.png\n\n// * * * * * *\n// *         *\n// *         *\n// *         *\n// *         *\n// * * * * * *\n\nint main()\n{\n\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n  {\n    for (int j = 1; j <= n; j++)\n    {\n      if (i == 1 || j == 1 || i == n || j == n)\n        cout << \"* \";\n      else\n        cout << \"  \";\n    }\n    cout << '\\n';\n  }\n  return 0;\n}"
    },
    {
      "name": "pattern_22",
      "filename": "pattern_22.cpp",
      "path": "practices/Patterns/pattern_22.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; i++)\n  {\n    for (int j = 1; j <= n; j++)\n    {\n    }\n  }\n  return 0;\n}"
    }
  ],
  "Self Practices": [
    {
      "name": "patter Recursive",
      "filename": "patterRecursive.c++",
      "path": "practices/selfPrectices/patterRecursive.c++",
      "content": "#include <iostream>\nusing namespace std;\n\nvoid patterNormal(int row, int col)\n{\n  if (row == 0)\n  {\n    return;\n  }\n  if (row > col)\n  {\n    patterNormal(row, col + 1);\n    cout << \"* \";\n  }\n  else\n  {\n    patterNormal(row - 1, 0);\n    cout << \"\\n\";\n  }\n}\n\nvoid patterR(int row, int col)\n{\n  if (row == 0)\n  {\n    return;\n  }\n  if (row > col)\n  {\n    cout << \"* \";\n    patterR(row, col + 1);\n  }\n  else\n  {\n    cout << \"\\n\";\n    patterR(row - 1, 0);\n  }\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  patterNormal(n, 0);\n\n  return 0;\n}"
    }
  ],
  "C++ Working": [
    {
      "name": "data Type",
      "filename": "dataType.c++",
      "path": "components/CppWorking/dataType.c++",
      "content": "#include <iostream>\nusing namespace std;\nint main()\n{\n  // * comment - This line should not exicut in the program\n  int a;                        // * Interager type value which store should be 4 bytes\n  long b;                       // * This also take the Interager value but it has Wider Range\n  float c;                      // * It store's the number Like \"2.3\"\n  double d = 2.4534;            // * wider form of float\n  long long g = 92348293838;    // * store the double value of long\n  long double k = 94809.323432; // * store the wider value then double\n  cout << \"Size of char \" << sizeof(char) << \" byte(s)\" << \"\\n\";\n  cout << \"Size of int \" << sizeof(int) << \" byte(s)\" << \"\\n\";\n  cout << \"Size of long \" << sizeof(long) << \" byte(s)\" << \"\\n\";\n  cout << \"Size of bool \" << sizeof(bool) << \" byte(s)\" << \"\\n\";\n  cout << \"Size of float \" << sizeof(float) << \" byte(s)\" << \"\\n\";\n  cout << \"Size of double \" << sizeof(double) << \" byte(s)\" << \"\\n\";\n  cout << \"Size of long long \" << sizeof(g) << \" byte(s)\" << \"\\n\";\n  cout << \"Size of long double \" << sizeof(k) << \" byte(s)\" << \"\\n\";\n\n  return 0;\n}"
    },
    {
      "name": "functions",
      "filename": "functions.c++",
      "path": "components/CppWorking/functions.c++",
      "content": "#include <iostream>\nusing namespace std;\n\n//* Functions are set of code which performs somethings\n//* Functions are used to modularise code -> breakdown the code into small , manageable and independent modules\n//* Function are used to ‚¨ÜÔ∏èes the readability\n//* Function are used to use the same code multiple time's\n\n//* Type of Functions\n//* void -> which does'nt return anything\n//* return -> it return something according to functions type\n//* parameterised -> like 'returnType function(parameterDataType parameter)';\n//* non-parameterised\n\n//* pass by value -> when the copy send to function and no any change the origanal\n// void change(int num)\n// {\n//   num += 5;\n//   cout << num << endl;\n//   num += 5;\n//   cout << num << endl;\n//   num += 5;\n//   cout << num << endl;\n// }\n// int main()\n// {\n//   int num = 10;\n//   change(num);\n//   cout << num << endl;\n//   return 0;\n// }\n\n//* pass by reference -> when the value it self the send to function and the change perform on original one\n//* whenever '&' this mean the value's address will be take by the variable\n// void change(int &num)\n// {\n//   num += 5;\n//   cout << num << endl;\n//   num += 5;\n//   cout << num << endl;\n//   num += 5;\n//   cout << num << endl;\n// }\n// int main()\n// {\n//   int num = 10;\n//   change(num);\n//   cout << num << endl;\n//   return 0;\n// }\n\n//! Note :- Array generally pass by reference without using '$' this\n"
    },
    {
      "name": "ifelse",
      "filename": "ifelse.cpp",
      "path": "components/CppWorking/ifelse.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n  // ? Write the programe for user so it Identify the is adult or Not\n\n  int a;\n  cin >> a;\n  if (a > 18)\n  {\n    cout << \"User is an Adult\";\n  }\n  else if (a == 18)\n  {\n    cout << \"User is becoming Adult\";\n  }\n  else\n  {\n    cout << \"User is user age!\";\n  }\n  // * Note :- The if statement should also excute alone when the else or else if is not define to it //\n\n  return 0;\n}"
    },
    {
      "name": "string",
      "filename": "string.c++",
      "path": "components/CppWorking/string.c++",
      "content": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n  // * Store the multi char values in on like \"Ronak\";\n  string a;\n  // string b;\n  // cin >> a >> b; // * It will take single word or when the space is started new value should started;\n  getline(cin, a); // * It will take the full Line as input but not take the other line;\n\n  cout << a;\n  return 0;\n}"
    },
    {
      "name": "switch",
      "filename": "switch.cpp",
      "path": "components/CppWorking/switch.cpp",
      "content": "#include <iostream>\nusing namespace std;\n\nint main()\n{\n  int day;\n  cin >> day;\n  switch (day)\n  {\n  case 1:\n    cout << \"Monday\";\n    break;\n  case 2:\n    cout << \"Tuesday\";\n    break;\n  case 3:\n    cout << \"Wednesday\";\n    break;\n  case 4:\n    cout << \"Thursday\";\n    break;\n  case 5:\n    cout << \"Friday\";\n    break;\n  case 6:\n    cout << \"Saturday\";\n    break;\n  case 7:\n    cout << \"Sunday\";\n    break;\n  default:\n    cout << \"Invalid\";\n  }\n\n  return 0;\n}"
    }
  ]
};

export default codeData;
